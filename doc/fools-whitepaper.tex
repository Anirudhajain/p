\documentclass{article}

\usepackage{times}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{xspace}
\usepackage{alltt}
\usepackage{color}
\usepackage{ifthen}
\usepackage{textcomp}
\usepackage{amssymb}

% references
\usepackage[colorlinks]{hyperref}
\usepackage[all]{hypcap}
\urlstyle{same}
\hypersetup{
    % true means draw the links themselves colored and do not draw a bounding box
    colorlinks=true, 
    linkcolor= blue,
    citecolor= blue,
    filecolor=blue,
    urlcolor= blue
}
\def\figureautorefname{Figure}%
\def\tableautorefname{Table}%
\def\partautorefname{Part}%
\def\appendixautorefname{Appendix}%
\def\chapterautorefname{Chapter}%
\def\sectionautorefname{Section}%

% source code
\definecolor{source}{gray}{0.9}
\usepackage{listings}
\lstset{
    language={},
    % characters
    tabsize=4,
    upquote=true,
    keepspaces=true,
    breaklines=true,
    breakautoindent=true,
    columns=fullflexible,
    basicstyle=\small\sffamily,
    showstringspaces=false,
    % numbering
    % numbers=left,
    % numbersep=5pt,
    % numberstyle=\tiny,
    % numberfirstline=true,
    % background
    frame=single, 
    framerule=0pt,
    backgroundcolor=\color{source},
    % captioning
    captionpos=b,
    % characters
    literate=
        {<<}{$<$\hspace{-0.25em}$<$}1
        {>>}{$>$\hspace{-0.25em}$>$}1
        {-}{{\sf -\hspace{-0.13em}-}}1
        {+}{\raisebox{0.08ex}{+}}1,
}
%\setlength{\fboxsep}{2pt}
%\setlength{\fboxrule}{0pt}
\newcommand{\ct}[1]{\colorbox{source}{\lstinline[basicstyle=\small\sffamily\upshape]{#1}}}

% comments
\newboolean{showcomments}
\setboolean{showcomments}{false}
%\setboolean{showcomments}{false}
\ifthenelse{\boolean{showcomments}}
  {\newcommand{\nb}[2]{
    \fbox{\bfseries\sffamily\scriptsize#1}
        {\small$\blacktriangleright$\textit{#2}$\blacktriangleleft$}}
   \newcommand{\version}{\emph{\scriptsize$-$Id$-$}}}
  {\newcommand{\nb}[2]{}
   \newcommand{\version}{}}
\newcommand{\fix}[1]{\nb{FIX}{#1}}
\newcommand{\todo}[1]{\nb{TODO}{#1}}
\newcommand{\tv}[1]{\nb{toon}{#1}}
\newcommand{\on}[1]{\nb{oscar}{#1}}

% graphics: \fig{position}{relative-width}{filename}{caption}
\DeclareGraphicsExtensions{.png,.jpg,.pdf,.eps,.gif}
\graphicspath{{figures/}}
\newcommand{\fig}[4]{
    \begin{figure}[#1]
        \centering
        \includegraphics[width=#2\textwidth]{#3}
        \caption{\label{fig:#3}#4}
    \end{figure}}

% abbreviations
\newcommand{\ie}{\emph{i.e.}\xspace}
\newcommand{\eg}{\emph{e.g.}\xspace}
\newcommand{\etc}{\emph{etc.}\xspace}

% references
\newcommand{\tabref}[1]{Table~\ref{tab:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}
\newcommand{\lstref}[1]{Listing~\ref{lst:#1}}


\title{Bootstrapping a truly reflective system}
\author{Toon Verwaest}

\begin{document}

\maketitle

\section{Introduction}

Programming languages define views on how to operate on machines.
Often this view is very distinct from what the device below is
actually executing, \ie the machine view. This makes it hard for
programs in a programming language to cross the barrier between
the language view and the machine view.

In order to make a language view work with the machine view, both
interpretation and compilation techniques have been identified.

Compilation has the advantage that a program can be statically
analyzed and transformed making it directly fast. The disadvantage is
that through optimizing compilation, the language view gets lost for
the runtime of the program. 

As opposed to compilation, interpretation keeps structures embedded in
the language view around at runtime. Generally the parts which are
around are limited to the amount of compilation needed to make
structures interpretable by the interpreter or virtual machine below.
In most languages there is always at least some step of compilation,
like parsing, which already partly bridges the gap between the
language's sourcecode (if any) and the machine view.

Keeping language views around at runtime is important for being able
to reflect on programs. The reflective capabilities of a language
are limited to the amount of language structures still around at
runtime. And those capabilities are also limited to the amount of
information the interpreter dynamically exposes to the language
about the language itself.

\subsection{Problem}
If we look at current reflective systems, we see that those systems
start from being virtually totally non-reflective and then add
reflective capabilities step by step. Only certain features are
exposed, hiding big parts of the internals of the language
implementation itself from programs written in the language. This
makes it difficult if not impossible to revert design decisions made
at interpreter level, at application level. And where it is possible,
the ways to work around design decisions are made expensive by the
overhead of automatic behaviour in the system below.

\subsection{Solution}
In order to avoid applications being stuck in the prison defined by
their puppet master the virtual machine, a fully reflective language
system has to be defined from the ground up. To the core of such a
system, nothing may be added or used without it being able to reflect
on itself. This implies the first core principle of a fully reflective
system:

\begin{itemize}
    \item Both the language system's native behaviour and its
          application behaviour have the same interface.
\end{itemize}

Native behaviour in a reflective system is an interesting topic by
itself. It is absolutely required for a system to be able to be
bootstrapped. Without native behaviour conceptual implementations
are bound to recurse infinitely in its own imagination. However,
native behaviour is the pinnacle of what is non-reflective. This
brings us to the second and third core principles for fully
reflective systems:

\begin{itemize}
    \item Native behaviour has to be localized and identified in the
          system.
    \item The amount of native behaviour used for the definition of
          the core concepts has to be minimized.
\end{itemize}

Minimizing the amount of concepts is again done by not allowing any
native to enter the system if it can be composed from other natives.

Note that this last principle clearly states that this is important
for the definition of the core. Of course it is important that a
language system can interface with external applications possibly
written in other languages. Such external applications can by
themselves be considered non-reflective or native parts of an
application. Since such natives are outside the scope of reflective
system, we cannot care about their implementation details.

When building a fully reflective system in modern programming
languages, we have to take care not to accidentally incorporate
semantics from the language below in our own system definition. This
disallows us to use for example the C stack with its stack frames,
unless reified properly. 

\section{Implementation of a fully reflective system}
Their are three basic elements which allow us to tie together a fully
reflective system:

\begin{itemize}
    \item In all languages there are locations where a group of
          objects define a context switch. The interface for both
          native and non-native behaviour is thus defined as a set of
          objects.
    \item In all languages, for such a context switch there is a
          clearly defined interpretation strategy. To be fully
          reflective each context switch links to its own
          interpretation strategy.
    \item A minimal part of the interpretation strategy has to be
          written natively. Such a strategy is also a context switch.
          The interpretation strategy of a native context switch is to
          natively execute the attached behaviour. Thus there is
          \emph{one} interpretation strategy hardwired in the system
          which executes the context switch linked to it natively.
\end{itemize}

While the last basic element allows us to suck in all sorts of native
behaviour, the third principle of reflective systems refrains us from
doing so. 

To be fair, in order to get the system running there is one hardwired
function which knows how to \emph{transfer} to a context, \ie enforce
a context switch in the system. However this primitive is the most
basic primitive possible to perform such task and can be seen as the
invisible power used by Baron Munchausen to get himself out of the swamp.
Our transfer primitive takes a context switch and switches to its
interpreter, while passing along a context object which encapsulates both
the interpreter and the original context switch. In case this interpreter
is non-native this process continues until a native interpreter is found.
Once one is found, the native interpreter is responsible for all
interpretation going on at lower levels.

\section{Uses of a fully reflective system}

\subsection{Language Implementation}
The most obvious use of a fully reflective system is to use it to
implement languages. Languages restrict reflection in a language
system and impose interpretation strategies. For this reason languages
are seen as (restrictive) \emph{views} on the system.

A language will define its own parser which will transform code into
reflective objects. Those reflective objects can then be interpreted
by custom interpreters attached by the language.

Since objects of all languages are defined to be interpreted by their
own attached interpreter, interoperability between languages written
for this system is a non-issue. Once an object of one language decides
to do a transfer, it is up to the object of possibly another language
to continue and probably return control to its caller at some point.

\subsection{Dynamic Optimization}
When all behaviour of a language is reflective, this automatically
implies that there is bound to be some interpretative overhead. If you
consider a limited amount of sub-method instructions which actually
get evaluated by sending the message \emph{eval} to one-another, you
see that the whole system is self interpretative. This
\emph{decentralized interpretation} of applications most likely ends
up having the same (or more in case of towers of interpreters)
overhead as normal interpreted systems.

The upside is that since everything at sub-method level happens
through message sends we can easily implement other methods on those
objects as well. We could for example add tracing evaluation methods.
When such a tracing method identifies a \emph{warm loop} \cite{JIT},
it could decide to generate native code for the behaviour and attach
it to the entry point of the traced loop. Next time when evaluation
hits the entry point, the node can then directly evaluate the native
behaviour rather than the interpreted version. In short, being able to
intercept sub-method calls allows us to write a JIT compiler for a
system inside the system itself.

\subsection{Submethod reflection}
In \cite{submethod reflectivity} important properties of submethod
reflectivity are identified. However, in their implementation there is
no real submethod reflectivity in the language itself. All submethod
structures are defined by bytecodes. This forces them to keep methods
around in twins. Both the AST compiled version of a method and
its bytecode compiled variant are combined into a reflective method.
At runtime the bytecode gets executed, but changes to the AST will
automatically result in regeneration of the bytecode. As such the AST
is in effect the reflective method and the bytecode a JIT compiled
version of the AST. 

Since our system and thus also our methods are fully defined in terms
of reflective objects, it is trivial to experiment with the ideas of
submethod reflectivity, without having to care about the
implementation details of how to actually make it run. The only thing
that needs to be done is implementing the correct meta-object protocol
on links.
\end{document}
