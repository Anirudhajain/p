\documentclass{article}

\usepackage{times}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{xspace}
\usepackage{alltt}
\usepackage{color}
\usepackage{ifthen}
\usepackage{textcomp}
\usepackage{amssymb}

% references
\usepackage[colorlinks]{hyperref}
\usepackage[all]{hypcap}
\urlstyle{same}
\hypersetup{
    % true means draw the links themselves colored and do not draw a bounding box
    colorlinks=true, 
    linkcolor= blue,
    citecolor= blue,
    filecolor=blue,
    urlcolor= blue
}
\def\figureautorefname{Figure}%
\def\tableautorefname{Table}%
\def\partautorefname{Part}%
\def\appendixautorefname{Appendix}%
\def\chapterautorefname{Chapter}%
\def\sectionautorefname{Section}%

% source code
\definecolor{source}{gray}{0.9}
\usepackage{listings}
\lstset{
    language={},
    % characters
    tabsize=4,
    upquote=true,
    keepspaces=true,
    breaklines=true,
    breakautoindent=true,
    columns=fullflexible,
    basicstyle=\small\sffamily,
    showstringspaces=false,
    % numbering
    % numbers=left,
    % numbersep=5pt,
    % numberstyle=\tiny,
    % numberfirstline=true,
    % background
    frame=single, 
    framerule=0pt,
    backgroundcolor=\color{source},
    % captioning
    captionpos=b,
    % characters
    literate=
        {<<}{$<$\hspace{-0.25em}$<$}1
        {>>}{$>$\hspace{-0.25em}$>$}1
        {-}{{\sf -\hspace{-0.13em}-}}1
        {+}{\raisebox{0.08ex}{+}}1,
}
%\setlength{\fboxsep}{2pt}
%\setlength{\fboxrule}{0pt}
\newcommand{\ct}[1]{\colorbox{source}{\lstinline[basicstyle=\small\sffamily\upshape]{#1}}}

% comments
\newboolean{showcomments}
\setboolean{showcomments}{false}
%\setboolean{showcomments}{false}
\ifthenelse{\boolean{showcomments}}
  {\newcommand{\nb}[2]{
    \fbox{\bfseries\sffamily\scriptsize#1}
        {\small$\blacktriangleright$\textit{#2}$\blacktriangleleft$}}
   \newcommand{\version}{\emph{\scriptsize$-$Id$-$}}}
  {\newcommand{\nb}[2]{}
   \newcommand{\version}{}}
\newcommand{\fix}[1]{\nb{FIX}{#1}}
\newcommand{\todo}[1]{\nb{TODO}{#1}}
\newcommand{\tv}[1]{\nb{toon}{#1}}
\newcommand{\on}[1]{\nb{oscar}{#1}}

% graphics: \fig{position}{relative-width}{filename}{caption}
\DeclareGraphicsExtensions{.png,.jpg,.pdf,.eps,.gif}
\graphicspath{{figures/}}
\newcommand{\fig}[4]{
    \begin{figure}[#1]
        \centering
        \includegraphics[width=#2\textwidth]{#3}
        \caption{\label{fig:#3}#4}
    \end{figure}}

% abbreviations
\newcommand{\ie}{\emph{i.e.}\xspace}
\newcommand{\eg}{\emph{e.g.}\xspace}
\newcommand{\etc}{\emph{etc.}\xspace}

% references
\newcommand{\tabref}[1]{Table~\ref{tab:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}
\newcommand{\lstref}[1]{Listing~\ref{lst:#1}}


\title{Bootstrapping a truly reflective system}
\author{Toon Verwaest}

\begin{document}

\maketitle

\section{Introduction}

Programming languages define views on how to operate on machines.
Often this view is very distinct from what the device below is
actually executing, \ie the machine view. This makes it hard for
programs in a programming language to cross the barrier between
the language view and the machine view.

In order to make a language view work with the machine view, both
interpretation and compilation techniques have been identified.

Compilation has the advantage that a program can be statically
analyzed and transformed making it directly fast. The disadvantage is
that through optimizing compilation, the language view gets lost for
the runtime of the program. 

As opposed to compilation, interpretation keeps structures embedded in
the language view around at runtime. Generally the parts which are
around are limited to the amount of compilation needed to make
structures interpretable by the interpreter or virtual machine below.
In most languages there is always at least some step of compilation,
like parsing, which already partly bridges the gap between the
language's sourcecode (if any) and the machine view.

Keeping language views around at runtime is important for being able
to reflect on programs. The reflective capabilities of a language
are limited to the amount of language structures still around at
runtime. And those capabilities are also limited to the amount of
information the interpreter dynamically exposes to the language
about the language itself.

\subsection{Problem}
If we look at current reflective systems, we see that those systems
start from being virtually totally non-reflective and then add
reflective capabilities step by step. Only certain features are
exposed, hiding big parts of the internals of the language
implementation itself from programs written in the language. This
makes it difficult if not impossible to revert design decisions made
at interpreter level, at application level. And where it is possible,
the ways to work around design decisions are made expensive by the
overhead of automatic behaviour in the system below.

Next to only being partly reflective, the bridge between interpreter-level and
application-level is often a dangerous one. This is due to the fact that 
encapsulation is only enforced both at interpreter-level for interpreter
structures and application-level for application structures. Encapsulation is
not preserved cross-meta-barrier as the interpreter has full
encapsulation-breaking access to application-level constructs. The more
reflective such a system is, the more brittle it gets. As an example thereof
you can see how easy it is to break a Smalltalk implementation by doing
something reflective at application-level resulting in crashing of the VM
below. While guards can be put in place almost everywhere to get around the
breaking of the VM, this is as unsafe as any application that does not use
proper encapsulation.

\subsection{Solution}
In order to avoid applications being stuck in the prison defined by
their puppet master the virtual machine, a fully reflective language
system has to be defined from the ground up. To the core of such a
system, nothing may be added or used without it being able to reflect
on itself. This implies the first core principle of a fully reflective
system:

\begin{itemize}
    \item Both the language system's native behaviour and its
          application behaviour have the same interface.
\end{itemize}

Native behaviour in a reflective system is an interesting topic by
itself. It is absolutely required for a system to be able to be
bootstrapped. Without native behaviour conceptual implementations
are bound to recurse infinitely in its own imagination. However,
native behaviour is the pinnacle of what is non-reflective. This
brings us to the second and third core principles for fully
reflective systems:

\begin{itemize}
    \item Native behaviour has to be localized and identified in the
          system.
    \item The amount of native behaviour used for the definition of
          the core concepts has to be minimized.
\end{itemize}

Minimizing the amount of concepts is again done by not allowing any
native to enter the system if it can be composed from other natives.

Note that this last principle clearly states that this is important
for the definition of the core. Of course it is important that a
language system can interface with external applications possibly
written in other languages. Such external applications can by
themselves be considered non-reflective or native parts of an
application. Since such natives are outside the scope of reflective
system, we cannot care about their implementation details.

% XXX add something about how we don't break it by maintaining the interfaces
% at all levels.

When building a fully reflective system in modern programming
languages, we have to take care not to accidentally incorporate
semantics from the language below in our own system definition. This
disallows us to use for example the C stack with its stack frames,
unless reified properly. 

\section{Implementation of a fully reflective system}
Their are three basic design considerations which allow us to tie
together a fully reflective system:

\begin{itemize}
    \item In all languages there are locations where a group of
          objects define a context switch. The interface for both
          native and non-native behaviour is thus defined as a set of
          objects.
    \item In all languages, for such a context switch there is a
          clearly defined interpretation strategy. To be fully
          reflective each context switch links to its own
          interpretation strategy.
    \item A minimal part of the interpretation strategy has to be
          written natively. Such a strategy is also a context switch.
          The interpretation strategy of a native context switch is to
          natively execute the attached behaviour. Thus there is
          \emph{one} interpretation strategy hardwired in the system
          which executes the context switch linked to it natively.
\end{itemize}

While the last design consideration allows us to suck in all sorts of
native behaviour, the third principle of reflective systems refrains us
from doing so. 

\subsection{Context -- Hardwired Data}
There is once type of object which is required to be built-in into the base
language system. Contexts are the representation of actions taken at
execution time. When an interpreter is activated, there is a context
representing the call to the interpreter. When this interpreter is non-native,
there is another context object representing the call to its meta-interpreter.
The meta-interpreter will be invoked by sending \verb$interpret:$ to it, with
the first invocation context as an argument. And so on, until the
meta-interpreter happens to be a native interpreter. This native interpreter
will in its execution be responsible for the execution of the tower of
interpreters below.

\subsection{Transfer -- Hardwired Behaviour}
In order to get the system running there is one hardwired
function which knows how to \emph{transfer} to a context, \ie enforce
a context switch in the system. This primitive is the most
basic primitive possible to perform such task. Transfer works as a
\emph{trampoline} for the current interpretation action. (but should be
replaced by real gotos?)

\subsection{Native Interpreters}
In order to make the whole base system reified, all other kinds of native
behaviour are made accessible via objects and message sends. While most
languages just have bytecode or assembler representing the actions to be taken
at runtime, our language system models all behaviour in terms of objects as
well. These objects are fully polymorphic objects which can be accessed at
runtime.

Since their is of course no system around which handles message
dispatch one way or another, all objects which cross the barrier between
native and non-native have a special type of interpreter, \ie a
\emph{native interpreter}. A native interpreter is an interpreter which knows
about a very limited set of native operations. Whenever the message evaluated
by an interpreter; or the message sent to an object; matches on of the native
operations, the native functionality corresponding to the message is directly
invoked. When such a message is not understood natively, another interpreter
which is linked to the native interpreter gets invoked with the original
context. Like this objects can natively understand certain messages, while
being able to still implement their own type of context evaluation.

Since native objects (objects interpreted by native interpreters) are
immutable with respect to their native behaviour, the set of types of native
objects is as limited as possible. This while being large enough to allow
developers to easily compose them to build any type of system. 

An important feature of native objects is that they follow the principle that
all native behaviour and non-native behaviour has to go through the same
interface. Since native objects are activated through a normal message sending
mechanism, they can be interchanged with objects which are not implemented
natively. These non-native objects will be a lot slower\footnote{This depends
on results in JIT compiling non-native structures. Eventually it might even be
faster!}, but might be a lot more elaborate and what is more important: they
can be changed from within the system.

\subsubsection{Environment}
Environments are passed around from behavioural object to behavioural object
and represent the data space of a running program. There are two primitive
operations linked with environments, one to store data at a certain location,
and one to retrieve data of a certain location.

\subsubsection{Behaviour}
Behavioural objects are used to represent submethod structures which decide
execution. Behavioural objects are evaluated natively by sending them the
message \verb$eval:$ with the enviroment in which they have to be evaluated as
an argument.

All of the following six native behavioural objects are required to bootstrap
a fully object oriented language system:

\begin{description}
    \item[IConst] is an object which when sent \verb$eval:$ it sets the first argument
                  of the return context to its assigned constant value.

    \item[ILists] are objects which nest other evaluable objects. When sent \verb$eval:$
                  they sent themselves \verb$return:env:continue:$ with \emph{nil}, the
                  environment passed to \verb$eval:$ and an initial index $0$ in the ilist of
                  evaluable objects.

                  Whenever \verb$return:env:continue:$ is receiver, the evaluable object at the
                  passed index is retrieved. The ilist then invokes \verb$eval:$ with the current
                  environment on the found object, after pointing the return context to itself
                  with the next index. While sending \verb$eval:$ to the last object in the ilist
                  the return context is linked to the return context of the ilist.


    \item[IVar]   is a type of object which relates code to runtime
                  environments. It natively triggers environment lookups and
                  stores.

    \item[IAssign] will evaluate the expression linked to it; after pointing
                   its continuation at an assignment of the linked variable.

    \item[ICall]   represents a location where the context switches to
                   another interpreter. This kind of action is an abstraction
                   which generalizes over all sorts of switches around in
                   other languages, such as method invocation, macro and
                   function calls, calls to predicates, \dots 

    \item[IScoped] is an object which contains a pointer to an environment and
                   another to an expression. Whenever evaluated it creates a
                   new sub-environment of the environment stored in the
                   iscoped and passes that environment along in the evaluation
                   of the expression linked to the iscoped.
\end{description}

\subsubsection{Primitives}
In order to make the system actually perform useful tasks, some extra native
behaviour needs to be installed. For method lookup to work, the system needs
to be able to test equality and perform actions depending on the results. This
requires a native way of comparing objects and the availability of boolean
objects. 

\subsection{Tying The Loose Ends Together}
At this point we have all the types of native structures that we need to
actually build useful reflective languages. However, the fact that native
objects have a fallback link to other interpreters means that we have to fill
them in somehow. \todo{we put classes there... should check if it would make
sense to put something else there; like a default erroring system. Layout of
the instruction objects is fixed though...}

\section{Uses of a fully reflective system}

\subsection{Language Skins}
The most obvious use of a fully reflective system is to use it to
implement languages. Languages restrict reflection in a language
system and impose interpretation strategies. For this reason languages
are seen as (restrictive) \emph{views} on the system.

A language will define its own parser which will transform code into
reflective objects. Those reflective objects can then be interpreted
by custom interpreters attached by the language.

Since objects of all languages are defined to be interpreted by their
own attached interpreter, interoperability between languages written
for this system is a non-issue. Once an object of one language decides
to do a transfer, it is up to the object of possibly another language
to continue and probably return control to its caller at some point.

The original parser will be written in a language skin available before
the conception of the new language. Given that a running system is persisted
using Smalltalk-style images, once the new language is properly
functional the \emph{bootstrapping parser} can be replaced by a parser
written in terms of the language itself.

\subsection{Dynamic Optimization\label{sec:dynamicoptimization}}
When all behaviour of a language is reflective, this automatically
implies that there is bound to be some interpretative overhead. If you
consider a limited amount of sub-method instructions which actually
get evaluated by sending the message \emph{eval} to one-another, you
see that the whole system is self interpretative. This
\emph{decentralized interpretation} of applications most likely ends
up having the same (or more in case of towers of interpreters)
overhead as normal interpreted systems.

The upside is that since everything at sub-method level happens
through message sends we can easily implement other methods on those
objects as well. We could for example add tracing evaluation methods.
When such a tracing method identifies a \emph{warm loop} \cite{JIT},
it could decide to generate native code for the behaviour and attach
it to the entry point of the traced loop. Next time when evaluation
hits the entry point, the node can then directly evaluate the native
behaviour rather than the interpreted version. In short, being able to
intercept sub-method calls allows us to write a JIT compiler for a
system inside the system itself.

\subsection{Submethod reflection}
In \cite{submethod reflectivity} important properties of submethod
reflectivity are identified. However, in their implementation there is
no real submethod reflectivity in the language itself. All submethod
structures are defined by bytecodes. This forces them to keep methods
around in twins. Both the AST compiled version of a method and
its bytecode compiled variant are combined into a reflective method.
At runtime the bytecode gets executed, but changes to the AST will
automatically result in regeneration of the bytecode. As such the AST
is in effect the reflective method and the bytecode a JIT compiled
version of the AST. 

Since our system and thus also our methods are fully defined in terms
of reflective objects, it is trivial to experiment with the ideas of
submethod reflectivity, without having to care about the
implementation details of how to actually make it run. The only thing
that needs to be done is implementing the correct meta-object protocol
on links.

A nice feature of submethod reflectivity is that it allows us to very
easily build a full aspect oriented language on top of it. So
submethod reflectivity enables aspect oriented capabilities of our
system. And as long as the correct interface is implemented
everywhere, the resulting code can even be optimized using the same
tracing JIT strategy as described in \secref{dynamicoptimization}.

\subsection{Reflective garbage collection}
Most modern dynamic languages incorporate a garbage collector within
their core to manage memory. Generally this garbage collection system
and its implementation is fully hidden from the language system
itself. In some cases limited reflection is provided through
primitives, as is the case for Smalltalk. The only existing languages
in which garbage collection is fully accessible from within (and
written in) the language itself, such as C and C++, are languages
where you can fully circumvent the managed memory system.

In the case of a fully reflective system, a fixed size of memory can
be allocated to the system when starting up. It has to be decided for
the system what kind of layout is used inside the system, and the way
of allocating natively has to be hardwired. However, how the objects
are managed in their lifespan can be fully decided from within the
system itself.

Since executing a garbage collector typically also requires a minimal
amount of objects to be around, the garbage collector will have to
preallocate all objects required for performing its task.

Given these few requirements a garbage collection mechanism can be
fully written inside the system itself. 

\subsection{Aliases}
written vm-level, here app-level = vm-level ->> app-level

\subsection{Debugging}
submethod are objects thus writing a debug-stepper is trivial, just
write another message which double dispatches back to the debugger.

\subsection{Refactoring}
submethod structures can be easily extracted to new types of
evaluatables, which do not need to be methods even (could be done with
submethod reflectivity as well?). In order to make methods out of them
some analysis needs to be done.

\subsection{Program Analysis}
can be done very easily on objects which all have the same kind of
interpreter. The interpreter defines how analysis has to be done, just
as with all other reflective capabilities. (Since in the end everything
is bound to our polymorphic behaviour instructions, at least some
level will be readable. Native behaviours will have to be called from
within the jitted code; or inlined directly. Maybe move this to JIT).

\section{Other Considerations}
\subsection{FFI}
FFI in a fully reflective language system should be fairly straightforward.
For native foreign functions, wrappers can be created in the same way as they
are created for native behaviour used by the system itself. Foreign
functionality written in high-level languages could be accommodated by writing
a new language skin. This last point would automatically enable all high-level
languages for which a skin exist to interoperate.

\subsection{Windows}
An oo windowing DSL like \emph{Glamour} should be used as a library for
creating graphical browsers of all sorts for the language system. FFI can be
used to bridge between \emph{glamour} and existing windowing toolkits.

\end{document}
