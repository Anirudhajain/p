(letrec ((car (lambda (cons) (cons 'car)))
         (cdr (lambda (cons) (cons 'cdr)))
         (Cons (newclass Cons Object (car cdr) ()
                ((car (s) ((getself s) 'objectAt: 0))
                 (car: (s new) ((getself s) 'objectAt:put: 0 new))
                 (cdr (s) ((getself s) 'objectAt: 1))
                 (cdr: (s new) ((getself s) 'objectAt:put: 1 new)))
                ()))
         (cons (lambda (l r)
            (let ((result (Cons 'new)))
                (result 'car: l)
                (result 'cdr: r)
                result)))
         (reverse (lambda (l)
            (let loop ((input l)
                       (result null))
                (if (eq? input null)
                    result
                    (loop (cdr input)
                          (cons (car input) result))))))
         (length (lambda (l)
            (let loop ((input l)
                       (result 0))
                (if (eq? input null)
                    result
                    (loop (cdr input) (+ result 1))))))
                    
         (StringScanner (newclass StringScanner Object 
                        (string position separator) ()
                ((pos        (s) ((getself s) 'objectAt: 1))
                 (pos:       (s new) ((getself s) 'objectAt:put: 1 new))
                 (string     (s) ((getself s) 'objectAt: 0))
                 (string:    (s new) ((getself s) 'objectAt:put: 0 new))
                 (separator  (s) ((getself s) 'objectAt: 2))
                 (separator: (s new) ((getself s) 'objectAt:put: 2 new))
                 (next       (s)  
                              (let* ((self (getself s))
                             (pos  (self 'pos))
                             (res  ((self 'string) 'objectAt: pos)))
                          (self 'objectAt:put: 1 (+ pos 1))
                          res))
                 (initialize (s) ((getself s) 'pos: 0) (getself s))
                 (skipWhitespaceWith: (s scope) (getself s))
                 (atEnd      (s) (let ((self (getself s)))
                              (= (self 'pos) 
                                 ((self 'string) 'size)))))
                ((on:        (s str) (let ((result ((getself s) 'new)))
                                  (result 'string: str)
                                  result)))))

       (Expression (newclass Expression Object (name omit) ()
            ((printString (s)
                (let ((self (getself s)))
                    (display (self 'name))
                    (display " (")
                    (display ((self 'class) 'name))
                    (display ")\n")))
             (match:in: (s input scope)
                (let* ((self (getself s))
                       (save (input 'pos))
                       (match (self 'privateMatch:in: input scope)))
                    (if (eq? match null)
                        (input 'pos: save)
                        (begin))
                    match))
             (privateMatch:in: (s input scope)
                ((getself s) 'subclassResponsibility))
             (asParser (s) (getself s))
             (name (s) ((getself s) 'objectAt: 0))
             (name: (s new) ((getself s) 'objectAt:put: 0 new))
             (omit (s) ((getself s) 'objectAt: 1))
             (omit: (s new) ((getself s) 'objectAt:put: 1 new))
             (plus (s) (OneOrMore 'for: (getself s)))
             (times (s) (ZeroOrMore 'for: (getself s)))
             (and (s) (AndPredicate 'for: (getself s)))
             (not (s) (NotPredicate 'for: (getself s)))
             (minus (s) (let ((result (NotPredicate 'for: (getself s))))
                            (result 'consume: #f)))
             (& (s other)
                (Sequence 'on:
                    (list (getself s) (other 'asParser))))
             (\| (s other)
                (OrderedChoice 'on:
                    (list (getself s) (other 'asParser))))
             (strongAnd: (s other)
                (let ((result ((getself s) '& other)))
                    (result 'skipWhitespace: #f)
                    result))
             (? (s) (ZeroOrOne 'for: (getself s)))
             (* (s) ((getself s) 'times))
             (strongTimes (s) (let ((result ((getself s) '*)))
                                (result 'skipWhitespace: #f)
                                result))
             (+ (s) ((getself s) 'plus))
             (strongPlus (s) (let ((result ((getself s) '+)))
                                (result 'skipWhitespace: #f)
                                result)))
            ()))

       (Sequence
            (newclass Sequence Expression (children skipWhitespace) ()
                ((children          (s) ((getself s) 'objectAt: 2))
                 (children:         (s new)
                    ((getself s) 'objectAt:put: 2 new))
                 (skipWhitespace    (s) ((getself s) 'objectAt: 3))
                 (skipWhitespace:   (s new)
                    ((getself s) 'objectAt:put: 3 new))
                 (<& (s child)
                    (let ((self (getself s)))
                        (self 'children: (cons child (self 'children)))))
                 (initialize (s)
                    (let ((self (getself s)))
                        (self 'omit: #f)
                        (self 'skipWhitespace: #t)
                        self))
                 (privateMatch:in: (s input scope)
                    (let ((self (getself s)))
                        (let loop ((matches null)
                                   (children (self 'children)))
                            (if (eq? children null)
                                (if (= (length matches) 1)
                                    (car matches)
                                    (reverse matches))
                                (let ((expr (car children)))
                                    (if (self 'skipWhitespace)
                                        (begin (input 'skipWhitespaceWith: scope))
                                        (begin))
                                    (let ((match (expr 'match:in: input scope)))
                                        (if (eq? null match)
                                            match
                                            (loop
                                                (if (expr 'omit)
                                                    matches
                                                    (cons match matches))
                                                (cdr children)))))))))
                )
                ((on: (s children)
                    (let ((result ((getself s) 'new)))
                        (result 'children: children)
                        result))
                )
            ))
       (OrderedChoice
            (newclass OrderedChoice Expression (children) ()
                ((children (s) ((getself s) 'objectAt: 2))
                 (children: (s new) ((getself s) 'objectAt:put: 2 new))
                 (privateMatch:in: (s input scope)
                    (let ((self (getself s)))
                        (let loop ((children (self 'children)))
                            (if (eq? null children)
                                null
                                (let* ((expr (car children))
                                       (match (expr 'match:in: input scope)))
                                    (if (eq? null match)
                                        (loop (cdr children))
                                        match))))))
                )
                ((on: (s children)
                    (let ((result ((getself s) 'new)))
                        (result 'children: children)
                        result)))
            ))
       (OneOrMore
            (newclass Repetition Expression (child skipWhitespace) ()
                ((child (s) ((getself s) 'objectAt: 2))
                 (child: (s new) ((getself s) 'objectAt:put: 2 new))
                 (skipWhitespace (s) ((getself s) 'objectAt: 3))
                 (skipWhitespace: (s new)
                    ((getself s) 'objectAt:put: 3 new))
                 (initialize (s)
                    (let ((self (getself s)))
                        (self 'skipWhitespace: #t)
                        self))
                 (privateMatch:in: (s input scope)
                    (let* ((self (getself s))
                           (child (self 'child)))
                        (let loop ((matches null)
                                   (save (input 'pos))
                                   (match (child 'match:in: input scope)))
                            (if (eq? match null)
                                (begin
                                    (input 'pos: save)
                                    (reverse matches))
                                (let ((pos (input 'pos)))
                                    (if (self 'skipWhitespace)
                                        (input 'skipWhitespaceWith: scope)
                                        (begin))
                                    (loop (cons match matches)
                                          pos
                                          (child 'match:in: input scope)))))))
                )
                ((for: (s child)
                    (let ((result ((getself s) 'new)))
                        (result 'child: child)
                        result)))
            ))
       (ZeroOrMore
            (newclass ZeroOrMore OneOrMore () ()
                ((privateMatch:in: (s input scope)
                    (let ((match ((getsuper s)
                                    (vector 'privateMatch:in: input scope))))
                        (if (eq? null match)
                            (list "")
                            match))))
                ()
            ))
       (ZeroOrOne
            (newclass ZeroOrOne OneOrMore () ()
                ((privateMatch:in: (s input scope)
                    (let* ((self (getself s))
                           (child (self 'child))
                           (match (child 'match:in: input scope)))
                        (if (eq? null match)
                            (list "")
                            (if (child 'omit)
                                (list "")
                                match)))))
                ()
            ))

       (AndPredicate
            (newclass AndPredicate OneOrMore () ()
                ()
                ()
            ))
       (NotPredicate
            (newclass NotPredicate OneOrMore (consume) ()
                ()
                ()
            ))
       (Parser
            (newclass Parser Expression (expression semantics
                                         extendScope separator) ()
                ((expression (s) ((getself s) 'objectAt: 2))
                 (expression: (s new) ((getself s) 'objectAt:put: 2 new))
                 (semantics (s) ((getself s) 'objectAt: 3))
                 (semantics: (s new) ((getself s) 'objectAt:put: 3 new))
                 (extendScope (s) ((getself s) 'objectAt: 4))
                 (extendScope: (s new) ((getself s) 'objectAt:put: 4 new))
                 (separator (s) ((getself s) 'objectAt: 5))
                 (separator: (s new) ((getself s) 'objectAt:put: 5 new))
                 (initialize: (s name)
                    (let ((self (getself s)))
                        (self 'name: name)
                        (self 'semantics: #f)
                        (self 'omit: #f)
                        (self 'extendScope: #f)
                        (self 'separator:
                            (((#\t 'asParser) '\| #\space) '\| "\n")))
                 )
                 (<= (s expression) ((getself s) 'expression: expression))
                 (match:in: (s input scope)
                    (let* ((self (getself s))
                           (semantics (self 'semantics)))
                        (let ((match ((self 'expression) 'match:in: input
                                            (self 'extend: scope))))
                            (if (eq? null match)
                                match
                                (if (eq? semantics #f)
                                    match
                                    (semantics scope match))))))
                 (do (s l) ((getself s) 'semantics: l))
                 (=~ (s input scope)
                    (let* ((self (getself s))
                           (scanner (StringScanner 'on: input))
                           (result (self 'match:in: scanner scope)))
                        (if (= (input 'size) (scanner 'pos))
                            (begin)
                            (begin
                                (display "WARNING: Peg did not match until end: ")
                                (display (scanner 'pos))
                                (display " of ")
                                (display (input 'size))
                                (display " (")
                                (display input)
                                (display ")\n")))
                        result))
                 (extend: (s scope)
                    (let* ((self (getself s))
                           (extend (self 'extendScope)))
                        (if (eq? extend #f)
                            scope
                            (extend 'for: scope)))))
                ((named: (s name)
                    (let ((result ((getself s) 'basicNew)))
                        (result 'initialize: name)
                        result)))
            ))
       (Terminal
            (newclass Terminal Expression (char) ()
                ((char (s) ((getself s) 'objectAt: 2))
                 (char: (s new) ((getself s) 'objectAt:put: 2 new))
                 (initialize (s)
                    (let ((self (getself s)))
                        (self 'omit: #f)
                        self))
                 (privateMatch:in: (s input scope)
                    (let* ((self (getself s))
                           (char (self 'char)))
                        (if (= (input 'next) char) char null)))
                )
                ((char: (s char)
                    (let ((result ((getself s) 'new)))
                        (result 'char: char)
                        result)))
            ))
        )

        (Character 'store:method: 'asParser
            (method (s) (Terminal 'char: (getself s))))

        (String 'store:method: 'asParser
            (method (s)
                (let* ((self (getself s))
                       (size (self 'size)))
                    (let loop ((idx 0) (result null))
                        (if (= idx size)
                            (Sequence 'on: (reverse result))
                            (loop (+ idx 1)
                                  (cons ((self 'objectAt: idx) 'asParser)
                                        result)))))))

       (load "boot/test/test-peg.p")

       ;(Object 'bla)
)
