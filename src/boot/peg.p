(letrec ((StringScanner (newclass StringScanner Object 
                        (string position separator) ()
                ((pos        (s) (self 'objectAt: 1))
                 (pos:       (s new) (self 'objectAt:put: 1 new))
                 (string     (s) (self 'objectAt: 0))
                 (string:    (s new) (self 'objectAt:put: 0 new))
                 (separator  (s) (self 'objectAt: 2))
                 (separator: (s new) (self 'objectAt:put: 2 new))
                 (remaining  (s)
                    (let ((self self))
                        (let ((pos (self 'pos))
                              (siz ((self 'string) 'size)))
                            (- siz pos))))
                 (next       (s)  
                              (let* ((self self)
                             (pos  (self 'pos))
                             (res  ((self 'string) 'objectAt: pos)))
                          (self 'objectAt:put: 1 (+ pos 1))
                          res))
                 (initialize (s) (self 'pos: 0) self)
                 (skipWhitespaceWith: (s scope) self)
                 (atEnd      (s) (let ((self self))
                              (= (self 'pos) 
                                 ((self 'string) 'size)))))
                ((on:        (s str) (let ((result (self 'new)))
                                  (result 'string: str)
                                  result)))))

       (Expression (newclass Expression Object (name omit) ()
            ((printString (s)
                (let ((self self))
                    (display (self 'name))
                    (display " (")
                    (display ((self 'class) 'name))
                    (display ")\n")))
             (match:in: (s input scope)
                (let* ((self self)
                       (save (input 'pos))
                       (match (self 'privateMatch:in: input scope)))
                    (if (eq? match null)
                        (input 'pos: save)
                        (begin))
                    match))
             (privateMatch:in: (s input scope)
                (self 'subclassResponsibility))
             (asParser (s) self)
             (name (s) (self 'objectAt: 0))
             (name: (s new) (self 'objectAt:put: 0 new))
             (omit (s) (self 'objectAt: 1))
             (omit: (s new)
                (self 'objectAt:put: 1 new)
                self)
             (plus (s) (OneOrMore 'for: self))
             (times (s) (ZeroOrMore 'for: self))
             (and (s) (AndPredicate 'for: self))
             (not (s) (NotPredicate 'for: self))
             (minus (s) (let ((result (NotPredicate 'for: self)))
                            (result 'consume: #f)))
             (& (s other)
                (Sequence 'on:
                    (list self (other 'asParser))))
             (\| (s other)
                (OrderedChoice 'on:
                    (list self (other 'asParser))))
             (strongAnd: (s other)
                (let ((result (self '& other)))
                    (result 'skipWhitespace: #f)
                    result))
             (? (s) (ZeroOrOne 'for: self))
             (* (s) (self 'times))
             (strongTimes (s) (let ((result (self '*)))
                                (result 'skipWhitespace: #f)
                                result))
             (+ (s) (self 'plus))
             (strongPlus (s) (let ((result (self '+)))
                                (result 'skipWhitespace: #f)
                                result)))
            ()))

       (Sequence
            (newclass Sequence Expression (children skipWhitespace) ()
                ((children          (s) (self 'objectAt: 2))
                 (children:         (s new)
                    (self 'objectAt:put: 2 new))
                 (skipWhitespace    (s) (self 'objectAt: 3))
                 (skipWhitespace:   (s new)
                    (self 'objectAt:put: 3 new))
                 (<& (s child)
                    (let ((self self))
                        (self 'children: (append(self 'children) (cons child)))
                        self))
                 (initialize (s)
                    (let ((self self))
                        (self 'omit: #f)
                        (self 'skipWhitespace: #t)
                        self))
                 (privateMatch:in: (s input scope)
                    (let ((self self))
                        (let loop ((matches null)
                                   (children (self 'children)))
                            (if (eq? children null)
                                (if (= (length matches) 1)
                                    (car matches)
                                    (reverse matches))
                                (let ((expr (car children)))
                                    (if (self 'skipWhitespace)
                                        (begin (input 'skipWhitespaceWith: scope))
                                        (begin))
                                    (let ((match (expr 'match:in: input scope)))
                                        (if (eq? null match)
                                            match
                                            (loop
                                                (if (expr 'omit)
                                                    matches
                                                    (cons match matches))
                                                (cdr children)))))))))
                )
                ((on: (s children)
                    (let ((result (self 'new)))
                        (result 'children: children)
                        result))
                )
            ))
       (OrderedChoice
            (newclass OrderedChoice Expression (children) ()
                ((children (s) (self 'objectAt: 2))
                 (children: (s new) (self 'objectAt:put: 2 new))
                 (<= (s child)
                    (let ((self self))
                        (self 'children: (append (self 'children) (cons child)))
                        self))

                 (privateMatch:in: (s input scope)
                    (let ((self self))
                        (let loop ((children (self 'children)))
                            (if (eq? null children)
                                null
                                (let* ((expr (car children))
                                       (match (expr 'match:in: input scope)))
                                    (if (eq? null match)
                                        (loop (cdr children))
                                        match))))))
                )
                ((on: (s children)
                    (let ((result (self 'new)))
                        (result 'children: children)
                        result)))
            ))
       (OneOrMore
            (newclass Repetition Expression (child skipWhitespace) ()
                ((child (s) (self 'objectAt: 2))
                 (child: (s new) (self 'objectAt:put: 2 new))
                 (skipWhitespace (s) (self 'objectAt: 3))
                 (skipWhitespace: (s new)
                    (self 'objectAt:put: 3 new))
                 (initialize (s)
                    (let ((self self))
                        (self 'skipWhitespace: #t)
                        self))
                 (privateMatch:in: (s input scope)
                    (let* ((self self)
                           (child (self 'child)))
                        (let loop ((matches null)
                                   (save (input 'pos))
                                   (match (child 'match:in: input scope)))
                            (if (eq? match null)
                                (begin
                                    (input 'pos: save)
                                    (reverse matches))
                                (let ((pos (input 'pos)))
                                    (if (self 'skipWhitespace)
                                        (input 'skipWhitespaceWith: scope)
                                        (begin))
                                    (loop (cons match matches)
                                          pos
                                          (child 'match:in: input scope)))))))
                )
                ((for: (s child)
                    (let ((result (self 'new)))
                        (result 'child: child)
                        result)))
            ))
       (ZeroOrMore
            (newclass ZeroOrMore OneOrMore () ()
                ((privateMatch:in: (s input scope)
                    (let ((match ((getsuper s)
                                    (vector 'privateMatch:in: input scope))))
                        (if (eq? null match)
                            (list "")
                            match))))
                ()
            ))
       (ZeroOrOne
            (newclass ZeroOrOne OneOrMore () ()
                ((privateMatch:in: (s input scope)
                    (let* ((self self)
                           (child (self 'child))
                           (match (child 'match:in: input scope)))
                        (if (eq? null match)
                            (list "")
                            (if (child 'omit)
                                (list "")
                                match)))))
                ()
            ))

       (AndPredicate
            (newclass AndPredicate OneOrMore () ()
                ()
                ()
            ))
       (NotPredicate
            (newclass NotPredicate OneOrMore (consume) ()
                ()
                ()
            ))
       (Parser
            (newclass Parser Expression (expression semantics
                                         extendScope separator) ()
                ((expression (s) (self 'objectAt: 2))
                 (expression: (s new) (self 'objectAt:put: 2 new))
                 (semantics (s) (self 'objectAt: 3))
                 (semantics: (s new) (self 'objectAt:put: 3 new))
                 (extendScope (s) (self 'objectAt: 4))
                 (extendScope: (s new) (self 'objectAt:put: 4 new))
                 (separator (s) (self 'objectAt: 5))
                 (separator: (s new) (self 'objectAt:put: 5 new))
                 (initialize: (s name)
                    (let ((self self))
                        (self 'name: name)
                        (self 'semantics: #f)
                        (self 'omit: #f)
                        (self 'extendScope: #f)
                        (self 'separator:
                            (((#\t 'asParser) '\| #\space) '\| "\n"))
                    )
                 )
                 (<= (s expression) (self 'expression: expression))
                 (match:in: (s input scope)
                    (let* ((self self)
                           (semantics (self 'semantics)))
                        (let ((match ((self 'expression) 'match:in: input
                                            (self 'extend: scope))))
                            (if (eq? null match)
                                match
                                (if (eq? semantics #f)
                                    match
                                    (semantics scope match))))))
                 (do: (s l) (self 'semantics: l))
                 (=~ (s input)
                    (let* ((self self)
                           (scanner (StringScanner 'on: input))
                           (result (self 'match:in: scanner null)))
                        (if (= (input 'size) (scanner 'pos))
                            (begin)
                            (begin
                                (display "WARNING: Peg did not match until end: ")
                                (display (scanner 'pos))
                                (display " of ")
                                (display (input 'size))
                                (display " (")
                                (display input)
                                (display ")\n")))
                        result))
                 (extend: (s scope)
                    (let* ((self self)
                           (extend (self 'extendScope)))
                        (if (eq? extend #f)
                            scope
                            (extend 'for: scope)))))
                ((named: (s name)
                    (let ((result (self 'basicNew)))
                        (result 'initialize: name)
                        result)))
            ))
        (Terminal
            (newclass Terminal Expression (str) ()
                ((string (s) (self 'objectAt: 2))
                 (string: (s new)
                    (if (= (new 'size) 0)
                        (error "terminal of size 0")
                        (begin))
                    (self 'objectAt:put: 2 new))
                 (initialize (s)
                    (let ((self self))
                        (self 'omit: #f)
                        self))
                 (privateMatch:in: (s input scope)
                    (let* ((self self)
                           (string (self 'string)))
                        (if (< (string 'size)
                               (input 'remaining))
                            (let loop ((idx 0))
                                (if (= idx (string 'size))
                                    string
                                    (if (char= (input 'next)
                                               (string 'objectAt: idx))
                                        (loop (+ idx 1))
                                        null)))
                            null)))
                )
                ((string: (s str)
                    (let ((result (self 'new)))
                        (result 'string: str)
                        result)))
            ))
        )

       (Character 'store:method: 'asParser
           (method (s)
                (let ((string (String 'basicNew: 1)))
                    (string 'objectAt:put: 0 self)
                    (Terminal 'string: string))))

       (String 'store:method: 'asParser
           (method (s) (Terminal 'string: self)))

       (load "boot/test/test-peg.p")
       (load "boot/smalltalk.p")
)
