(letrec ((StringScanner (newclass StringScanner Object 
                        (string position separator) ()
                ((pos        (self super) (self 'objectAt: 1))
                 (pos:       (self super new) (self 'objectAt:put: 1 new))
                 (string     (self super) (self 'objectAt: 0))
                 (string:    (self super new) (self 'objectAt:put: 0 new))
                 (separator  (self super) (self 'objectAt: 2))
                 (separator: (self super new) (self 'objectAt:put: 2 new))
                 (remaining  (self super)
                        (let ((pos (self 'pos))
                              (siz ((self 'string) 'size)))
                            (- siz pos)))
                 (next       (self super)  
                        (let* ((pos  (self 'pos))
                               (res  ((self 'string) 'objectAt: pos)))
                          (self 'objectAt:put: 1 (+ pos 1))
                          res))
                 (initialize (self super) (self 'pos: 0) self)
                 (skipWhitespaceWith: (self super scope) self)
                 (atEnd      (self super)
                              (= (self 'pos) 
                                 ((self 'string) 'size))))
                ((on:        (self super str) (let ((result (self 'new)))
                                  (result 'string: str)
                                  result)))))

       (Expression (newclass Expression Object (name omit) ()
            ((printString (self super)
                (display (self 'name))
                (display " (")
                (display ((self 'class) 'name))
                (display ")\n"))
             (match:in: (self super input scope)
                (let* ((save (input 'pos))
                       (match (self 'privateMatch:in: input scope)))
                    (if (eq? match null)
                        (input 'pos: save)
                        (begin))
                    match))
             (privateMatch:in: (self super input scope)
                (self 'subclassResponsibility))
             (asParser (self super) self)
             (name (self super) (self 'objectAt: 0))
             (name: (self super new) (self 'objectAt:put: 0 new))
             (omit (self super) (self 'objectAt: 1))
             (omit: (self super new)
                (self 'objectAt:put: 1 new)
                self)
             (plus (self super) (OneOrMore 'for: self))
             (times (self super) (ZeroOrMore 'for: self))
             (and (self super) (AndPredicate 'for: self))
             (not (self super) (NotPredicate 'for: self))
             (minus (self super) (let ((result (NotPredicate 'for: self)))
                            (result 'consume: #f)))
             (& (self super other)
                (Sequence 'on:
                    (list self (other 'asParser))))
             (\| (self super other)
                (OrderedChoice 'on:
                    (list self (other 'asParser))))
             (strongAnd: (self super other)
                (let ((result (self '& other)))
                    (result 'skipWhitespace: #f)
                    result))
             (? (self super) (ZeroOrOne 'for: self))
             (* (self super) (self 'times))
             (strongTimes (self super) (let ((result (self '*)))
                                (result 'skipWhitespace: #f)
                                result))
             (+ (self super) (self 'plus))
             (strongPlus (self super) (let ((result (self '+)))
                                (result 'skipWhitespace: #f)
                                result)))
            ()))

       (Sequence
            (newclass Sequence Expression (children skipWhitespace) ()
                ((children          (self super) (self 'objectAt: 2))
                 (children:         (self super new)
                    (self 'objectAt:put: 2 new))
                 (skipWhitespace    (self super) (self 'objectAt: 3))
                 (skipWhitespace:   (self super new)
                    (self 'objectAt:put: 3 new))
                 (<& (self super child)
                    (self 'children: (append(self 'children) (cons child)))
                    self)
                 (initialize (self super)
                    (self 'omit: #f)
                    (self 'skipWhitespace: #t)
                    self)
                 (privateMatch:in: (self super input scope)
                    (let loop ((matches null)
                               (children (self 'children)))
                        (if (eq? children null)
                            (if (= (length matches) 1)
                                (car matches)
                                (reverse matches))
                            (let ((expr (car children)))
                                (if (self 'skipWhitespace)
                                    (begin (input 'skipWhitespaceWith: scope))
                                    (begin))
                                (let ((match (expr 'match:in: input scope)))
                                    (if (eq? null match)
                                        match
                                        (loop
                                            (if (expr 'omit)
                                                matches
                                                (cons match matches))
                                            (cdr children))))))))
                )
                ((on: (self super children)
                    (let ((result (self 'new)))
                        (result 'children: children)
                        result))
                )
            ))
       (OrderedChoice
            (newclass OrderedChoice Expression (children) ()
                ((children (self super) (self 'objectAt: 2))
                 (children: (self super new) (self 'objectAt:put: 2 new))
                 (<= (self super child)
                    (self 'children: (append (self 'children) (cons child)))
                    self)

                 (privateMatch:in: (self super input scope)
                     (let loop ((children (self 'children)))
                         (if (eq? null children)
                             null
                             (let* ((expr (car children))
                                    (match (expr 'match:in: input scope)))
                                 (if (eq? null match)
                                     (loop (cdr children))
                                     match)))))
                )
                ((on: (self super children)
                    (let ((result (self 'new)))
                        (result 'children: children)
                        result)))
            ))
       (OneOrMore
            (newclass Repetition Expression (child skipWhitespace) ()
                ((child (self super) (self 'objectAt: 2))
                 (child: (self super new) (self 'objectAt:put: 2 new))
                 (skipWhitespace (self super) (self 'objectAt: 3))
                 (skipWhitespace: (self super new)
                    (self 'objectAt:put: 3 new))
                 (initialize (self super)
                     (self 'skipWhitespace: #t)
                     self)
                 (privateMatch:in: (self super input scope)
                    (let ((child (self 'child)))
                        (let loop ((matches null)
                                   (save (input 'pos))
                                   (match (child 'match:in: input scope)))
                            (if (eq? match null)
                                (begin
                                    (input 'pos: save)
                                    (reverse matches))
                                (let ((pos (input 'pos)))
                                    (if (self 'skipWhitespace)
                                        (input 'skipWhitespaceWith: scope)
                                        (begin))
                                    (loop (cons match matches)
                                          pos
                                          (child 'match:in: input scope)))))))
                )
                ((for: (self super child)
                    (let ((result (self 'new)))
                        (result 'child: child)
                        result)))
            ))
       (ZeroOrMore
            (newclass ZeroOrMore OneOrMore () ()
                ((privateMatch:in: (self super input scope)
                    (let ((match (super
                            (vector 'privateMatch:in: input scope))))
                        (if (eq? null match)
                            (list "")
                            match))))
                ()
            ))
       (ZeroOrOne
            (newclass ZeroOrOne OneOrMore () ()
                ((privateMatch:in: (self super input scope)
                    (let* ((child (self 'child))
                           (match (child 'match:in: input scope)))
                        (if (eq? null match)
                            (list "")
                            (if (child 'omit)
                                (list "")
                                match)))))
                ()
            ))

       (AndPredicate
            (newclass AndPredicate OneOrMore () ()
                ()
                ()
            ))
       (NotPredicate
            (newclass NotPredicate OneOrMore (consume) ()
                ()
                ()
            ))
       (Parser
            (newclass Parser Expression (expression semantics
                                         extendScope separator) ()
                ((expression (self super) (self 'objectAt: 2))
                 (expression: (self super new) (self 'objectAt:put: 2 new))
                 (semantics (self super) (self 'objectAt: 3))
                 (semantics: (self super new) (self 'objectAt:put: 3 new))
                 (extendScope (self super) (self 'objectAt: 4))
                 (extendScope: (self super new) (self 'objectAt:put: 4 new))
                 (separator (self super) (self 'objectAt: 5))
                 (separator: (self super new) (self 'objectAt:put: 5 new))
                 (initialize: (self super name)
                    (self 'name: name)
                    (self 'semantics: #f)
                    (self 'omit: #f)
                    (self 'extendScope: #f)
                    (self 'separator:
                        (((#\t 'asParser) '\| #\space) '\| "\n"))
                 )
                 (<= (self super expression) (self 'expression: expression))
                 (match:in: (self super input scope)
                    (let ((semantics (self 'semantics)))
                        (let ((match ((self 'expression) 'match:in: input
                                            (self 'extend: scope))))
                            (if (eq? null match)
                                match
                                (if (eq? semantics #f)
                                    match
                                    (semantics scope match))))))
                 (do: (self super l) (self 'semantics: l))
                 (=~ (self super input)
                    (let* ((scanner (StringScanner 'on: input))
                           (result (self 'match:in: scanner null)))
                        (if (= (input 'size) (scanner 'pos))
                            (begin)
                            (begin
                                (warn "\nPeg did not match until end: ")
                                (warn (scanner 'pos))
                                (warn " of ")
                                (warn (input 'size))
                                (warn " (")
                                (warn input)
                                (warn ")")
                                ))
                        result))
                 (extend: (self super scope)
                    (let ((extend (self 'extendScope)))
                        (if (eq? extend #f)
                            scope
                            (extend 'for: scope)))))
                ((named: (self super name)
                    (let ((result (self 'basicNew)))
                        (result 'initialize: name)
                        result)))
            ))
        (Terminal
            (newclass Terminal Expression (str) ()
                ((string (self super) (self 'objectAt: 2))
                 (string: (self super new)
                    (if (= (new 'size) 0)
                        (error "terminal of size 0")
                        (begin))
                    (self 'objectAt:put: 2 new))
                 (initialize (self super)
                     (self 'omit: #f)
                     self)
                 (privateMatch:in: (self super input scope)
                    (let ((string (self 'string)))
                        (if (< (string 'size)
                               (input 'remaining))
                            (let loop ((idx 0))
                                (if (= idx (string 'size))
                                    string
                                    (if (char= (input 'next)
                                               (string 'objectAt: idx))
                                        (loop (+ idx 1))
                                        null)))
                            null)))
                )
                ((string: (self super str)
                    (let ((result (self 'new)))
                        (result 'string: str)
                        result)))
            ))
        (Range
            (newclass Range Expression (start stop) ()
                ((start (self super) (self 'objectAt: 2))
                 (start: (self super new) (self 'objectAt:put: 2 new))
                 (stop (self super) (self 'objectAt: 3))
                 (stop: (self super new) (self 'objectAt:put: 3 new))
                 (privateMatch:in: (self super input scope)
                    (let ((char (input 'next)))
                        (if (eq? char null)
                            char
                            (if (>= char (self 'start)) 
                                (if (<= char (self 'stop))
                                    (char 'asString)
                                    (null))
                                (null)))))
                 )
                ((between:and: (self super start stop)
                    (let ((result (self 'new)))
                        (result 'start: start)
                        (result 'stop: stop)
                        result)))
        ))
        )
       (Character 'store:method: 'asParser
           (method (self super)
                (let ((string (String 'basicNew: 1)))
                    (string 'objectAt:put: 0 self)
                    (Terminal 'string: string))))

       (String 'store:method: 'asParser
           (method (self super) (Terminal 'string: self)))

       (String 'store:method: 'asChoice
           (method (self super) 
                (let ((result OrderedChoice))
                    (let loop ((idx 0))
                        (if (= idx (self 'size))
                            result
                            (result '<= ((self 'objectAt: idx) 'asParser)
                            (loop (+ idx 1))))))))

       (String 'store:method: 'asRange
            (method (self super)
                (if (char= (self 'objectAt: 1) #\-) 
                    (if (= (self 'size) 3)
                        (Range 'between:and: (self 'objectAt: 0) (self 'objectAt: 2))
                        (error "Cannot convert String to Range: wrong string size "))
                    (error "Cannot convert String to Range: second character is not -"))))

       (load "boot/test/test-peg.p")
       (load "boot/test/test-ast.p")
       (load "boot/smalltalk.p")
)
