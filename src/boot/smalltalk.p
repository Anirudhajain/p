(let ((SmalltalkParser (newclass SmallParser Object (parsers id) ()
       ((assignmentOp (s)
            (((":=" 'asParser) '\| #\_) 'omit: #t))
        (initializeAnnotation (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "ANNOTATION")))
                (p '<= ((((#\< 'asParser) 'omit: #t) '&
                            ((self 'keywordAnnotation) '\|
                             (self 'unaryAnnotation)))
                            '<& ((#\> 'asParser) 'omit: #t)))
                p))
            )
        (initializeArray (s) 
            (let ((self (getself s)))
            (let ((array (Parser 'named: "ARRAY")))
                (array '<= ((((#\( 'asParser) 'omit: #t) '&
                            (((((   (self 'numberConstant) '\|
                                    (self 'stringConstant)) '<=
                                    (self 'symbolInArray)) '<=
                                    (self 'symbolConstant)) '<=
                                    (self 'characterConstant)) '<=
                                    array)) 
                            '<& ((#\) 'asParser) 'omit: #t)))
                (array 'semantics: (lambda (result) result))
                array)))
        (initializeArrayConst (s)
            (let ((self (getself s)))
                (((#\# 'asParser) 'omit: #t) '& (self 'array))))
        (initializeAssignmentExpressions (s)
            (let ((self (getself s)))
                (((self 'variableName) '& (self 'assignmentOp )) 'times)))
        (initializeBar (s)
            ((#\| 'asParser) 'omit: #t))
        (initializeBinaryExpression (s) ; TODO this is not complete yet
            (let ((self (getself s)))
            (self 'preStoreBinaryObjectDescription)))
        (initializeBinaryMessageDefinition (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "BINARY-ARGUMENT")))
                (p '<= ((self 'binarySelector) '& (self 'parameterName)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBinaryMessageExpression (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "BINARY-MESSAGE-EXPRESSION")))
                (p '<= ((self 'binarySelector) '& (self 'unaryObjectDescription)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBinaryObjectDescription (s)
            (let ((self (getself s)))
                ((self 'binaryExpression)
                (self 'binaryObjectDescription))))
        (initializeBinarySelector (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "BINARY-SELECTOR")))
                (p '<= ((((self 'specialCharacter) '\| #\-) 'strongAnd: ((self 'specialCharacter) 'strongTimes)) '\| #\|))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBlock (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "BLOCK")))
                (p '<= ((((((#\[ 'asParser) 'omit: #t) '&
                        (((self 'blockArguments) '& (self 'bar)) 'optional)) '<&
                        ((self 'temporaries) 'optional)) '<&
                        (self 'statements)) '<&
                        ((#\] 'asParser) 'omit: #t)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBlockArguments (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "BLOCK-ARGUMENTS")))
                (p '<= ((((#\: 'asParser) 'omit: #t) '& (self 'identifier)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBraceExpression (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "BRACE-EXPRESSION")))
                (p '<= (((((#\{ 'asParser) 'omit: #t) '&
                        ((self 'subExpression) 'times)) '<&
                        (self 'expression)) '<&
                        ((#\} 'asParser) 'omit: #t)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCapitalIdentifier (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "CAPITAL-IDENTIFIER")))
                (p '<= ((self 'uppercase) 'strongAnd: (((self 'letter) '\| (self 'decimalDigit)) 'strongTimes)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCascadedMessageExpression (s)
            (let ((self (getself s)))
                (self 'expression)
                (self 'cascadedMessageExpression)))
        (initializeCharacter (s) ;TODO implement, need String 'asPEGChoice
            (let ((self (getself s))) 
                ))
        (initializeCharacterConstant (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "CHARACTER-CONSTANT")))
                (p '<= (((#\$ 'asParser) 'omit: #t) 'strongAnd: (self 'character)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCommentFormat (s)
            (let ((commentBorder (#\" 'asParser)))
                ((commentBorder 'strongAnd: ((commentBorder 'not) 'strongTimes)) '<& commentBorder)
                commentBorder))
        (initializeDecimalDigit (s) ;TODO implement, need String asPEGRange
            )
        (initializeExpression (s) ;TODO implement
            )
        (initializeFinalExpression (s)
            (let ((self (getself s)))
                ((self 'expression) '& ((#\. 'asParser) 'omit: #t))))
        (initializeIdentifier (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "IDENTIFIER")))
                (p '<= ((self 'letter) 'strongAnd: (((self 'letter) '\| (self 'decimalDigit)) 'strongTimes)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeyword (s)
            (let ((self (getself s)))
                ((self 'identifier) 'strongAnd: ((#\: 'asParser) 'omit: #t))))
        (initializeKeywordAnnotation (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "KEYWORD-ANNOTATION")))
                (p '<= (((self 'keyword) '& (self 'primary)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeywordExpression (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "KEYWORD-EXPRESSION")))
                (p '<= ((self 'binaryObjectDescription) '& (self 'keywordMessageExpression)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeywordMessageExpression (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "KEYWORD-MESSAGE-EXPRESSION")))
                (p '<= (((self 'keyword) '& (self 'binaryObjectDescription)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeywordsArguments (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "KEYWORDS-ARGUMENTS")))
                (p '<= (((self 'keyword) '& (self 'parameterName)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeLetter (s)
            (let ((self (getself s)))
                ((self 'lowercase) '\| (self 'uppercase))))
        (initializeLiteral (s)
            (let ((self (getself s)))
            (let ((result ((self 'numberConstant) '\| (self 'symbolConstant))))
                (((result '<= (self 'characterConstant)) '<= (self 'stringConstant)) '<= (self 'arrayConstant))
                result)))
        (initializeLowercase (s) ;TODO implement, need String asPEGRange
            )
        (initializeMessageExpression (s)
            (let ((self (getself s)))
                (self 'expression)
                ((self 'messageExpression) 'separator: (self 'separator))))
        (initializeMesssagePattern (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "MESSAGE-PATTERN")))
                (p '<= (((self 'keywordsArguments) '\| (self 'binaryMessageDefiniton)) '<=
                            (self 'unaryMessageDefinition)))
                p)))
        (initializeMethod (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "METHOD")))
                (p '<= (((((self 'messagePattern)
                        '& ((self 'temporaries) 'optional))
                        '<& ((self 'annotation) 'times))
                        '<& (self 'statements))
                        '<& (self 'separator)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeNumberConstant (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "NUMBER")))
                (p '<= ((self 'decimalDigit) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeParameterName (s)
            (let ((self (getself s)))
                (self 'identifier)))
        (initializePrimary (s)
            (let ((self (getself s)))
                (self 'expression)
                (self 'primary)))
        (initializePrimaryVariable (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "PRIMARY-VARIABLE")))
                (p '<= (self 'identifier))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeReturn (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "RETURN")))
                (p '<= (((#\^ 'asParser) 'omit: #t) '& (self 'finalExpression)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeScopedExpression (s)
            (let ((self (getself s)))
                ((((#\( 'asParser) 'omit: #t) '& (self 'expression)) '<& ((#\) 'asParser) 'omit: #t))))
        (initializeSeparator (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "COMMENT")))
                (p '<= ((((Parser 'separator) '\| (self 'commentFormat)) 'strongTimes) 'omit: #t))
                p)))
        (initializeSpecialCharacter (s) ;TODO, need String 'asPEGChoice
            )
        (initializeStatements (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "STATEMENTS")))
                (p '<= (((self 'subExpression) 'times) '& (((self 'return) '\| (self 'finalExpression)) 'optional)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeString (s)
            (let* ((self (getself s))
                   (stringBorder (("'" 'asParser) 'omit: #t)))
            (let ((p (Parser 'named: "STRING")))
                (p '<= (((stringBorder 'strongAnd: ((stringBorder 'not) 'strongTimes)) '<& stringBorder) 'strongPlus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeStringConstant (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "STRING-CONSTANT")))
                (p '<= (self 'string))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeSubExpression (s)
            (let ((self (getself s)))
                ((self 'expression) '& ((#\. 'asParser) 'omit: #t))))
        (initializeSymbol (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "SYMBOL")))
              (p '<= ((((self 'symbolKeywords) '\| (self 'identifier)) 
                        '<= (self 'binarySelector))
                        '<= (self 'string)))
              p)))
        (initializeSymbolConstant (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "SYMBOL-CONSTANT")))
                (p '<= (((#\# 'asParser) 'omit: #t) 'strongAnd: (self 'symbol)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeSymbolInArray (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "SYMBOL-IN-ARRAY")))
                (p '<= (self 'symbol))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeSymbolKeywords (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "SYMBOL-KEYWORDS")))
                (p '<= ((self 'keyword) 'strongPlus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeTemporaries (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "TEMPORARIES")))
                (p '<= (((self 'bar) '& ((self 'variableName) 'times)) '<& (self 'bar)))))) 
        (initializeUnaryAnnotation (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "UNARY-ANNOTATION")))
                (p '<= (self 'unarySelector))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryExpression (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "UNARY-EXPRESSION")))
                (p '<= ((self 'primary) '& ((self 'unarySelector) 'plus)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryMessageDefinition (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "UNARY-MESSSAGE-DEFINITION")))
                (p '<= (self 'unarySelector))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryMessageExpression (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "UNARY-MESSSAGE-EXPRESSION")))
                (p '<= (self 'unarySelector))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryObjectDescription (s)
            (let ((self (getself s)))
                ((self 'unaryExpression) '\| (self 'primary))))
        (initializeUnarySelector (s) ;TODO implement consume
            (let ((self (getself s)))
            (let ((p (Parser 'named: "UNARY-SELECTOR")))
                (p '<= ((self 'identifier) 'strongAnd: (((#\: 'asParser) 'not) 'consume: #f)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUppercase (s) ;TODO implement, need String 'asPEGRange
            )
        (initializeVariableName (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "VARIABLE-NAME")))
                (p '<= (self 'identifier))
                (p 'semantics: (lambda (result) result))
                p)))

        ;this is where one could add more methods
        ;write parser for st using the one in pharo
       )())))
    
    (load "boot/test/test-smalltalk.p"))
