(let ((SmalltalkParser (newclass SmallParser Object (parsers id) ()
       ((assignmentOp (s)
            (((":=" 'asParser) '\| #\_) 'omit: #t))
        (initializeAnnotation (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "ANNOTATION")))
                (p '<= ((((#\< 'asParser) 'omit: #t) '&
                            ((self 'keywordAnnotation) '\|
                             (self 'unaryAnnotation)))
                            '<& ((#\> 'asParser) 'omit: #t)))
                p))
            )
        (initializeArray (s) 
            (let ((self (getself s)))
            (let ((array (Parser 'named: "ARRAY")))
                (array '<= ((((#\( 'asParser) 'omit: #t) '&
                            (((((   (self 'numberConstant) '\|
                                    (self 'stringConstant)) '<=
                                    (self 'symbolInArray)) '<=
                                    (self 'symbolConstant)) '<=
                                    (self 'characterConstant)) '<=
                                    array)) 
                            '<& ((#\) 'asParser) 'omit: #t)))
                (array 'semantics: (lambda (result) result))
                array)))
        (initializeArrayConst (s)
            (let ((self (getself s)))
                (((#\# 'asParser) 'omit: #t) '& (self 'array))))
        (initializeAssignmentExpressions (s)
            (let ((self (getself s)))
                (((self 'variableName) '& (self 'assignmentOp )) 'times)))
        (initializeBar (s)
            ((#\| 'asParser) 'omit: #t))
        (initializeBinaryExpression (s) ; TODO this is not complete yet
            (let ((self (getself s)))
            (self 'preStoreBinaryObjectDescription)))
        (initializeBinaryMessageDefinition (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "BINARY-ARGUMENT")))
                (p '<= ((self 'binarySelector) '& (self 'parameterName)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBinaryMessageExpression (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "BINARY-MESSAGE-EXPRESSION")))
                (p '<= ((self 'binarySelector) '& (self 'unaryObjectDescription)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBinaryObjectDescription (s)
            (let ((self (getself s)))
                ((self 'binaryExpression)
                (self 'binaryObjectDescription))))
        (initializeBinarySelector (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "BINARY-SELECTOR")))
                (p '<= ((((self 'specialCharacter) '\| #\-) 'strongAnd: ((self 'specialCharacter) 'strongTimes)) '\| #\|))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBlock (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "BLOCK")))
                (p '<= ((((((#\[ 'asParser) 'omit: #t) '&
                        (((self 'blockArguments) '& (self 'bar)) 'optional)) '<&
                        ((self 'temporaries) 'optional)) '<&
                        (self 'statements)) '<&
                        ((#\] 'asParser) 'omit: #t)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBlockArguments (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "BLOCK-ARGUMENTS")))
                (p '<= ((((#\: 'asParser) 'omit: #t) '& (self 'identifier)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBraceExpression (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "BRACE-EXPRESSION")))
                (p '<= (((((#\{ 'asParser) 'omit: #t) '&
                        ((self 'subExpression) 'times)) '<&
                        (self 'expression)) '<&
                        ((#\} 'asParser) 'omit: #t)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCapitalIdentifier (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "CAPITAL-IDENTIFIER")))
                (p '<= ((self 'uppercase) 'strongAnd: (((self 'letter) '\| (self 'decimalDigit)) 'strongTimes)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCascadedMessageExpression (s)
            (let ((self (getself s)))
                (self 'expression)
                (self cascadedMessageExpression)))
        (initializeCharacter (s) ;TODO implement, need String 'asPEGChoice
            (let ((self (getself s))) 
                ))
        (initializeCharacterConstant (s)
            (let ((self (getself s)))
            (let ((p (Parser 'named: "CHARACTER-CONSTANT")))
                (p '<= (((#\$ 'asParser) 'omit: #t) 'strongAnd: (self 'character)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCommentFormat (s)
            (let ((commentBorder (#\" 'asParser)))
                ((commentBorder 'strongAnd: ((commentBorder 'not) 'strongTimes)) '<& commentBorder)
                commentBorder))
        (initializeDecimalDigit (s) ;TODO implement, need String asPEGRange
            )
        (initializeExpression (s) ;TODO implement
            )
        (initializeFinalExpression (s)
            (let ((self (getself s)))
                ((self 'expression) '& ((#\. 'asParser) 'omit: #t))

        ;this is where one could add more methods
        ;write parser for st using the one in pharo
       )
       ())))
    
    (load "boot/test/test-smalltalk.p"))
