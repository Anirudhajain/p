(let ((SmalltalkParser (newclass SmallParser Object (parsers id) ()
       ((assignmentOp (self super)
            (((":=" 'asParser) '\| #\_) 'omit: #t))
        (parsers (self super) (self 'objectAt: 0))
        (parsers: (self super aDictionary) (self 'objectAt:put: 0 aDictionary))
        (initializeAnnotation (self super)
            (let ((self self))
            (let ((p (Parser 'named: "ANNOTATION")))
                (p '<= ((((#\< 'asParser) 'omit: #t) '&
                            ((self 'keywordAnnotation) '\|
                             (self 'unaryAnnotation)))
                            '<& ((#\> 'asParser) 'omit: #t)))
                p))
            )
        (initializeArray (self super) 
            (let ((self self))
            (let ((array (Parser 'named: "ARRAY")))
                (array '<= ((((#\( 'asParser) 'omit: #t) '&
                            (((((   (self 'numberConstant) '\|
                                    (self 'stringConstant)) '<=
                                    (self 'symbolInArray)) '<=
                                    (self 'symbolConstant)) '<=
                                    (self 'characterConstant)) '<=
                                    array)) 
                            '<& ((#\) 'asParser) 'omit: #t)))
                (array 'semantics: (lambda (result) result))
                array)))
        (initializeArrayConst (self super)
            (let ((self self))
                (((#\# 'asParser) 'omit: #t) '& (self 'array))))
        (initializeAssignmentExpressions (self super)
            (let ((self self))
                (((self 'variableName) '& (self 'assignmentOp )) 'times)))
        (initializeBar (self super)
            ((#\| 'asParser) 'omit: #t))
        (initializeBinaryExpression (self super)
            (let ((self self))
            (self 'preStoreBinaryObjectDescription)
            ((self 'parsers) 'at:ifAbsentPut: 'binaryExpression 
                (let ((p (Parser 'named: "BINARY-EXPRESSION")))
                    (p '<= (((self 'unaryObjectDescription) '& (self 'binarySelector))
                            '<& (self 'binaryObjectDescription))
                    (p 'semantics: (lambda (result) result))
                    p)))
            (self 'injectBinaryObjectDescription)
            (self 'binaryExpression)
            ))
        (initializeBinaryMessageDefinition (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BINARY-ARGUMENT")))
                (p '<= ((self 'binarySelector) '& (self 'parameterName)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBinaryMessageExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BINARY-MESSAGE-EXPRESSION")))
                (p '<= ((self 'binarySelector) '& (self 'unaryObjectDescription)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBinaryObjectDescription (self super)
            (let ((self self))
                ((self 'binaryExpression)
                (self 'binaryObjectDescription))))
        (initializeBinarySelector (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BINARY-SELECTOR")))
                (p '<= ((((self 'specialCharacter) '\| #\-) 'strongAnd: ((self 'specialCharacter) 'strongTimes)) '\| #\|))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBlock (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BLOCK")))
                (p '<= ((((((#\[ 'asParser) 'omit: #t) '&
                        (((self 'blockArguments) '& (self 'bar)) 'optional)) '<&
                        ((self 'temporaries) 'optional)) '<&
                        (self 'statements)) '<&
                        ((#\] 'asParser) 'omit: #t)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBlockArguments (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BLOCK-ARGUMENTS")))
                (p '<= ((((#\: 'asParser) 'omit: #t) '& (self 'identifier)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBraceExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BRACE-EXPRESSION")))
                (p '<= (((((#\{ 'asParser) 'omit: #t) '&
                        ((self 'subExpression) 'times)) '<&
                        (self 'expression)) '<&
                        ((#\} 'asParser) 'omit: #t)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCapitalIdentifier (self super)
            (let ((self self))
            (let ((p (Parser 'named: "CAPITAL-IDENTIFIER")))
                (p '<= ((self 'uppercase) 'strongAnd: (((self 'letter) '\| (self 'decimalDigit)) 'strongTimes)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCascadedMessageExpression (self super)
            (let ((self self))
                (self 'expression)
                (self 'cascadedMessageExpression)))
        (initializeCharacter (self super)
            ((((("'[]{}()_^;$#:-|." 'asChoice) '\| (Parser 'separator)) 
                '<= (self 'decimalDigit))
                '<= (self 'letter))
                '<= (self 'specialCharacter))
                             )
        (initializeCharacterConstant (self super)
            (let ((self self))
            (let ((p (Parser 'named: "CHARACTER-CONSTANT")))
                (p '<= (((#\$ 'asParser) 'omit: #t) 'strongAnd: (self 'character)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCommentFormat (self super)
            (let ((commentBorder (#\" 'asParser)))
                ((commentBorder 'strongAnd: ((commentBorder 'not) 'strongTimes)) '<& commentBorder)
                commentBorder))
        (initializeDecimalDigit (self super) ;TODO implement, need String asPEGRange
            )
        (initializeExpression (self super) ;TODO implement
            )
        (initializeFinalExpression (self super)
            (let ((self self))
                ((self 'expression) '& ((#\. 'asParser) 'omit: #t))))
        (initializeIdentifier (self super)
            (let ((self self))
            (let ((p (Parser 'named: "IDENTIFIER")))
                (p '<= ((self 'letter) 'strongAnd: (((self 'letter) '\| (self 'decimalDigit)) 'strongTimes)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeyword (self super)
            (let ((self self))
                ((self 'identifier) 'strongAnd: ((#\: 'asParser) 'omit: #t))))
        (initializeKeywordAnnotation (self super)
            (let ((self self))
            (let ((p (Parser 'named: "KEYWORD-ANNOTATION")))
                (p '<= (((self 'keyword) '& (self 'primary)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeywordExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "KEYWORD-EXPRESSION")))
                (p '<= ((self 'binaryObjectDescription) '& (self 'keywordMessageExpression)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeywordMessageExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "KEYWORD-MESSAGE-EXPRESSION")))
                (p '<= (((self 'keyword) '& (self 'binaryObjectDescription)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeywordsArguments (self super)
            (let ((self self))
            (let ((p (Parser 'named: "KEYWORDS-ARGUMENTS")))
                (p '<= (((self 'keyword) '& (self 'parameterName)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeLetter (self super)
            (let ((self self))
                ((self 'lowercase) '\| (self 'uppercase))))
        (initializeLiteral (self super)
            (let ((self self))
            (let ((result ((self 'numberConstant) '\| (self 'symbolConstant))))
                (((result '<= (self 'characterConstant)) '<= (self 'stringConstant)) '<= (self 'arrayConstant))
                result)))
        (initializeLowercase (self super) ;TODO implement, need String asPEGRange
            )
        (initializeMessageExpression (self super)
            (let ((self self))
                (self 'expression)
                ((self 'messageExpression) 'separator: (self 'separator))))
        (initializeMesssagePattern (self super)
            (let ((self self))
            (let ((p (Parser 'named: "MESSAGE-PATTERN")))
                (p '<= (((self 'keywordsArguments) '\| (self 'binaryMessageDefiniton)) '<=
                            (self 'unaryMessageDefinition)))
                p)))
        (initializeMethod (self super)
            (let ((self self))
            (let ((p (Parser 'named: "METHOD")))
                (p '<= (((((self 'messagePattern)
                        '& ((self 'temporaries) 'optional))
                        '<& ((self 'annotation) 'times))
                        '<& (self 'statements))
                        '<& (self 'separator)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeNumberConstant (self super)
            (let ((self self))
            (let ((p (Parser 'named: "NUMBER")))
                (p '<= ((self 'decimalDigit) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeParameterName (self super)
            (let ((self self))
                (self 'identifier)))
        (initializePrimary (self super)
            (let ((self self))
                (self 'expression)
                (self 'primary)))
        (initializePrimaryVariable (self super)
            (let ((self self))
            (let ((p (Parser 'named: "PRIMARY-VARIABLE")))
                (p '<= (self 'identifier))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeReturn (self super)
            (let ((self self))
            (let ((p (Parser 'named: "RETURN")))
                (p '<= (((#\^ 'asParser) 'omit: #t) '& (self 'finalExpression)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeScopedExpression (self super)
            (let ((self self))
                ((((#\( 'asParser) 'omit: #t) '& (self 'expression)) '<& ((#\) 'asParser) 'omit: #t))))
        (initializeSeparator (self super)
            (let ((self self))
            (let ((p (Parser 'named: "COMMENT")))
                (p '<= ((((Parser 'separator) '\| (self 'commentFormat)) 'strongTimes) 'omit: #t))
                p)))
        (initializeSpecialCharacter (self super) ;TODO, need String 'asPEGChoice
            )
        (initializeStatements (self super)
            (let ((self self))
            (let ((p (Parser 'named: "STATEMENTS")))
                (p '<= (((self 'subExpression) 'times) '& (((self 'return) '\| (self 'finalExpression)) 'optional)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeString (self super)
            (let* ((self self)
                   (stringBorder (("'" 'asParser) 'omit: #t)))
            (let ((p (Parser 'named: "STRING")))
                (p '<= (((stringBorder 'strongAnd: ((stringBorder 'not) 'strongTimes)) '<& stringBorder) 'strongPlus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeStringConstant (self super)
            (let ((self self))
            (let ((p (Parser 'named: "STRING-CONSTANT")))
                (p '<= (self 'string))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeSubExpression (self super)
            (let ((self self))
                ((self 'expression) '& ((#\. 'asParser) 'omit: #t))))
        (initializeSymbol (self super)
            (let ((self self))
            (let ((p (Parser 'named: "SYMBOL")))
              (p '<= ((((self 'symbolKeywords) '\| (self 'identifier)) 
                        '<= (self 'binarySelector))
                        '<= (self 'string)))
              p)))
        (initializeSymbolConstant (self super)
            (let ((self self))
            (let ((p (Parser 'named: "SYMBOL-CONSTANT")))
                (p '<= (((#\# 'asParser) 'omit: #t) 'strongAnd: (self 'symbol)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeSymbolInArray (self super)
            (let ((self self))
            (let ((p (Parser 'named: "SYMBOL-IN-ARRAY")))
                (p '<= (self 'symbol))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeSymbolKeywords (self super)
            (let ((self self))
            (let ((p (Parser 'named: "SYMBOL-KEYWORDS")))
                (p '<= ((self 'keyword) 'strongPlus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeTemporaries (self super)
            (let ((self self))
            (let ((p (Parser 'named: "TEMPORARIES")))
                (p '<= (((self 'bar) '& ((self 'variableName) 'times)) '<& (self 'bar)))))) 
        (initializeUnaryAnnotation (self super)
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-ANNOTATION")))
                (p '<= (self 'unarySelector))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-EXPRESSION")))
                (p '<= ((self 'primary) '& ((self 'unarySelector) 'plus)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryMessageDefinition (self super)
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-MESSSAGE-DEFINITION")))
                (p '<= (self 'unarySelector))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryMessageExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-MESSSAGE-EXPRESSION")))
                (p '<= (self 'unarySelector))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryObjectDescription (self super)
            (let ((self self))
                ((self 'unaryExpression) '\| (self 'primary))))
        (initializeUnarySelector (self super) ;TODO implement consume
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-SELECTOR")))
                (p '<= ((self 'identifier) 'strongAnd: (((#\: 'asParser) 'not) 'consume: #f)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUppercase (self super) ;TODO implement, need String 'asPEGRange
            )
        (initializeVariableName (self super)
            (let ((self self))
            (let ((p (Parser 'named: "VARIABLE-NAME")))
                (p '<= (self 'identifier))
                (p 'semantics: (lambda (result) result))
                p)))
        (injectBinaryObjectDescription (self super)
            (let ((self self))
                ((self 'binaryObjectDescription) 
                    '<= ((self 'binaryExpression) '\| (self 'unaryObjectDescription)))))
        (injectCascadedMessageExpression (self super) ;TODO implement
            (let ((self self))
                ))
        (injectMessageExpression (self super)
            ((self 'messageExpression) 
                '<= (((self 'keywordExpression) '\| (self 'binaryExpression))
                        '<= (self 'unaryExpression))))
        (injectPrimary (self super)
            ((self 'primary)
                '<= (((((self 'primaryVariable) '\| (self 'literal))
                    '<= (self 'block))
                    '<= (self 'braceExpression))
                    '<= (self 'scopedExpression))))
        (preStoreBinaryDescription (self super)
            ((self 'parsers) 'at:ifAbsentPut: 'binaryObjectDescription (lambda () (Parser 'named: "BINARY-OBJECT-DESCRIPTION"))))
        (preStoreCascadedMessageExpression (self super)
            ((self 'parsers) 'at:ifAbsentPut: 'cascadedMessageExpression (lambda () (Parser 'named: "CASCADED-MESSAGE-EXPRESSION"))))
        (preStoreMessageExpression (self super)
            ((self 'parsers) 'at:ifAbsentPut: 'messageExpression (lambda () (Parser 'named: "MESSAGE-EXPRESSION"))))
        (preStorePrimary (self super)
            ((self 'parsers) 'at:ifAbsentPut: 'primary (lambda () (Parser 'named: "PRIMARY"))))
       )())))
    
    (load "boot/test/test-smalltalk.p"))
