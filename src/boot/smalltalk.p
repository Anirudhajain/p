(letrec ((SmalltalkParser (newclass SmallParser Object (parsers id) ()
       ((assignmentOp (self super)
            (((":=" 'asParser) '\| #\_) 'omit: #t))
        (parsers (self super) (self 'objectAt: 0))
        (parsers: (self super aDictionary) (self 'objectAt:put: 0 aDictionary))
        (id (self super) (self 'objectAt: 1))
        (id: (self super new) (self 'objectAt:put: 1 new))
        (initialize (self super)
            (self 'parsers: (Dictionary 'new))
            (self 'id: 0)
            self)
     
        ;XXX should check if the generated symbolname is valid, or we will end up
        ;in an infinit loop!
        (doesNotUnderstand:in:with: (self super message env args) 
            (let ((selector (("initialize" 'concat: (message 'capitalized)) 'asSymbol)))
                ;(display selector) 
                ;(display "\n")
                ((self 'parsers) 'at:ifAbsentPut:
                                 message (lambda () (self selector)))
                ))

        (initializeAnnotation (self super)
            (let ((p (Parser 'named: "ANNOTATION")))
                (p '<= ((((#\< 'asParser) 'omit: #t) '&
                            ((self 'keywordAnnotation) '\|
                             (self 'unaryAnnotation)))
                            '<& ((#\> 'asParser) 'omit: #t)))
                p))
        (initializeArray (self super) 
            (let ((array (Parser 'named: "ARRAY")))
                (array '<= ((((#\( 'asParser) 'omit: #t) '&
                            (((((   (self 'numberConstant) '\|
                                    (self 'stringConstant)) '<=
                                    (self 'symbolInArray)) '<=
                                    (self 'symbolConstant)) '<=
                                    (self 'characterConstant)) '<=
                                    array)) 
                            '<& ((#\) 'asParser) 'omit: #t)))
                (array 'semantics: (lambda (scope match) match)) ;TODO implement semantics
                array))
        (initializeArrayConstant (self super)
                (((#\# 'asParser) 'omit: #t) '& (self 'array)))
        (initializeAssignmentExpressions (self super)
                (((self 'variableName) '& (self 'assignmentOp )) 'times))
        (initializeBar (self super)
            ((#\| 'asParser) 'omit: #t))
        (initializeBinaryExpression (self super)
            (self 'preStoreBinaryObjectDescription)
            ((self 'parsers) 'at:ifAbsentPut: 'binaryExpression 
                (let ((p (Parser 'named: "BINARY-EXPRESSION")))
                    (p '<= (((self 'unaryObjectDescription) '& (self 'binarySelector))
                            '<& (self 'binaryObjectDescription)))
                    (p 'semantics: (lambda (scope match) match))
                    p))
            (self 'injectBinaryObjectDescription)
            (self 'binaryExpression)
            )

        (initializeBinaryMessageDefinition (self super)
            (let ((p (Parser 'named: "BINARY-ARGUMENT")))
                (p '<= ((self 'binarySelector) '& (self 'parameterName)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeBinaryMessageExpression (self super)
            (let ((p (Parser 'named: "BINARY-MESSAGE-EXPRESSION")))
                (p '<= ((self 'binarySelector) '& (self 'unaryObjectDescription)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeBinaryObjectDescription (self super)
                (self 'binaryExpression)
                (self 'binaryObjectDescription))
        (initializeBinarySelector (self super)
            (let ((p (Parser 'named: "BINARY-SELECTOR")))
                (p '<= ((((self 'specialCharacter) '\| #\-) 'strongAnd: ((self 'specialCharacter) 'strongTimes)) '\| #\|))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeBlock (self super)
            (let ((p (Parser 'named: "BLOCK")))
                (p '<= ((((((#\[ 'asParser) 'omit: #t) '&
                        (((self 'blockArguments) '& (self 'bar)) '?)) '<&
                        ((self 'temporaries) '?)) '<&
                        (self 'statements)) '<&
                        ((#\] 'asParser) 'omit: #t)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeBlockArguments (self super)
            (let ((p (Parser 'named: "BLOCK-ARGUMENTS")))
                (p '<= ((((#\: 'asParser) 'omit: #t) '& (self 'identifier)) 'plus))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeBraceExpression (self super)
            (let ((p (Parser 'named: "BRACE-EXPRESSION")))
                (p '<= (((((#\{ 'asParser) 'omit: #t) '&
                        ((self 'subExpression) 'times)) '<&
                        (self 'expression)) '<&
                        ((#\} 'asParser) 'omit: #t)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeCapitalIdentifier (self super)
            (let ((p (Parser 'named: "CAPITAL-IDENTIFIER")))
                (p '<= ((self 'uppercase) 'strongAnd: (((self 'letter) '\| (self 'decimalDigit)) 'strongTimes)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeCascadedMessageExpression (self super)
                (self 'expression)
                (self 'cascadedMessageExpression))
        (initializeCharacter (self super)
            ((((("[]{}()_^;$#:-|." 'asChoice) '\| (Parser 'separators)) 
                '<= (self 'decimalDigit))
                '<= (self 'letter))
                '<= (self 'specialCharacter))
                             )
        (initializeCharacterConstant (self super)
            (let ((p (Parser 'named: "CHARACTER-CONSTANT")))
                (p '<= (((#\$ 'asParser) 'omit: #t) 'strongAnd: (self 'character)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeCommentFormat (self super)
            (let ((commentBorder (#\" 'asParser)))
                ((commentBorder 'strongAnd: ((commentBorder 'not) 'strongTimes)) '<& commentBorder)
                commentBorder))
        (initializeDecimalDigit (self super) 
            ("0-9" 'asRange))     
        (initializeExpression (self super) 
            (let ((p (Parser 'named: "EXPRESSION")))
                (self 'preStorePrimary)
                (self 'preStoreMessageExpression)
                (self 'preStoreCascadedMessageExpression)
                ((self 'parsers) 'objectAt:put: 'expression 
                    (begin (p '<= ((self 'assignmentExpressions) 
                            '& (((self 'cascadedMessageExpression)
                            '\| (self 'messageExpression))
                            '<= (self 'primary))))
                    (p 'semantics: (lambda (scope match) match))
                    p))
                ;After having built the expression parser, we inject the parsers into their stubs.
                (self 'injectPrimary)
                (self 'injectMessageExpression)
                (self 'injectCascadedMessageExpression)
        ))
        (initializeFinalExpression (self super)
                ((self 'expression) '& ((#\. 'asParser) 'omit: #t)))
        (initializeIdentifier (self super)
            (let ((p (Parser 'named: "IDENTIFIER")))
                (p '<= ((self 'letter) 'strongAnd: 
                            (((self 'letter) '\| (self 'decimalDigit)) 'strongTimes)))
                (p 'semantics: (lambda (scope match) 
                    (list->string (map (lambda (s) (s 'objectAt: 0)) (cons (car match) (car (cdr match)))))))
                p))
        (initializeKeyword (self super)
                ((self 'identifier) 'strongAnd: ((#\: 'asParser) 'omit: #t)))
        (initializeKeywordAnnotation (self super)
            (let ((p (Parser 'named: "KEYWORD-ANNOTATION")))
                (p '<= (((self 'keyword) '& (self 'primary)) 'plus))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeKeywordExpression (self super)
            (let ((p (Parser 'named: "KEYWORD-EXPRESSION")))
                (p '<= ((self 'binaryObjectDescription) '& (self 'keywordMessageExpression)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeKeywordMessageExpression (self super)
            (let ((p (Parser 'named: "KEYWORD-MESSAGE-EXPRESSION")))
                (p '<= (((self 'keyword) '& (self 'binaryObjectDescription)) 'plus))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeKeywordsArguments (self super)
            (let ((p (Parser 'named: "KEYWORDS-ARGUMENTS")))
                (p '<= (((self 'keyword) '& (self 'parameterName)) 'plus))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeLetter (self super)
                ((self 'lowercase) '\| (self 'uppercase)))
        (initializeLiteral (self super)
            (let ((result ((self 'numberConstant) '\| (self 'symbolConstant))))
                (((result '<= (self 'characterConstant)) '<= (self 'stringConstant)) '<= (self 'arrayConstant))
                result))
        (initializeLowercase (self super)
            ("a-z" 'asRange))
        (initializeMessageExpression (self super)
                (self 'expression)
                ((self 'messageExpression) 'separator: (self 'separator)))
        (initializeMesssagePattern (self super)
            (let ((p (Parser 'named: "MESSAGE-PATTERN")))
                (p '<= (((self 'keywordsArguments) '\| (self 'binaryMessageDefiniton)) '<=
                            (self 'unaryMessageDefinition)))
                p))
        (initializeMethod (self super)
            (let ((p (Parser 'named: "METHOD")))
                (p '<= (((((self 'messagePattern)
                        '& ((self 'temporaries) '?))
                        '<& ((self 'annotation) 'times))
                        '<& (self 'statements))
                        '<& (self 'separator)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeNumberConstant (self super)
            (let ((p (Parser 'named: "NUMBER")))
                (p '<= ((self 'decimalDigit) 'plus))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeParameterName (self super)
                (self 'identifier))
        (initializePrimary (self super)
                (self 'expression)
                (self 'primary))
        (initializePrimaryVariable (self super)
            (let ((p (Parser 'named: "PRIMARY-VARIABLE")))
                (p '<= (self 'identifier))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeReturn (self super)
            (let ((p (Parser 'named: "RETURN")))
                (p '<= (((#\^ 'asParser) 'omit: #t) '& (self 'finalExpression)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeScopedExpression (self super)
                ((((#\( 'asParser) 'omit: #t) '& (self 'expression)) '<& ((#\) 'asParser) 'omit: #t)))
        (initializeSeparator (self super)
            (let ((p (Parser 'named: "COMMENT")))
                (p '<= ((((Parser 'separators)  '\| (self 'commentFormat)) 'strongTimes) 'omit: #t))
                p))
        (initializeSpecialCharacter (self super)
            ("+*/\\~<>=@%?!&`,'" 'asChoice))
        (initializeStatements (self super)
            (let ((p (Parser 'named: "STATEMENTS")))
                (p '<= (((self 'subExpression) 'times) '& (((self 'return) '\| (self 'finalExpression)) '?)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeString (self super)
            (let ((stringBorder (("'" 'asParser) 'omit: #t)))
            (let ((p (Parser 'named: "STRING")))
                (p '<= (((stringBorder 'strongAnd: ((stringBorder 'not) 'strongTimes)) '<& stringBorder) 'strongPlus))
                (p 'semantics: (lambda (scope match) match))
                p)))
        (initializeStringConstant (self super)
            (let ((p (Parser 'named: "STRING-CONSTANT")))
                (p '<= (self 'string))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeSubExpression (self super)
                ((self 'expression) '& ((#\. 'asParser) 'omit: #t)))
        (initializeSymbol (self super)
            (let ((p (Parser 'named: "SYMBOL")))
              (p '<= ((((self 'symbolKeywords) '\| (self 'identifier)) 
                        '<= (self 'binarySelector))
                        '<= (self 'string)))
              p))
        (initializeSymbolConstant (self super)
            (let ((p (Parser 'named: "SYMBOL-CONSTANT")))
                (p '<= (((#\# 'asParser) 'omit: #t) 'strongAnd: (self 'symbol)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeSymbolInArray (self super)
            (let ((p (Parser 'named: "SYMBOL-IN-ARRAY")))
                (p '<= (self 'symbol))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeSymbolKeywords (self super)
            (let ((p (Parser 'named: "SYMBOL-KEYWORDS")))
                (p '<= ((self 'keyword) 'strongPlus))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeTemporaries (self super)
            (let ((p (Parser 'named: "TEMPORARIES")))
                (p '<= (((self 'bar) '& ((self 'variableName) 'times)) '<& (self 'bar)))
                p)) 
        (initializeUnaryAnnotation (self super)
            (let ((p (Parser 'named: "UNARY-ANNOTATION")))
                (p '<= (self 'unarySelector))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeUnaryExpression (self super)
            (let ((p (Parser 'named: "UNARY-EXPRESSION")))
                (p '<= ((self 'primary) '& ((self 'unarySelector) 'plus)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeUnaryMessageDefinition (self super)
            (let ((p (Parser 'named: "UNARY-MESSSAGE-DEFINITION")))
                (p '<= (self 'unarySelector))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeUnaryMessageExpression (self super)
            (let ((p (Parser 'named: "UNARY-MESSSAGE-EXPRESSION")))
                (p '<= (self 'unarySelector))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeUnaryObjectDescription (self super)
                ((self 'unaryExpression) '\| (self 'primary)))
        (initializeUnarySelector (self super) 
            (let ((p (Parser 'named: "UNARY-SELECTOR")))
                (p '<= ((self 'identifier) 'strongAnd: (((#\: 'asParser) 'not) 'consume: #f)))
                (p 'semantics: (lambda (scope match) match))
                p))
        (initializeUppercase (self super) 
            ("A-Z" 'asRange))
        (initializeVariableName (self super)
            (let ((p (Parser 'named: "VARIABLE-NAME")))
                (p '<= (self 'identifier))
                (p 'semantics: (lambda (scope match) match))
                p))
        (injectBinaryObjectDescription (self super)
                ((self 'binaryObjectDescription) 
                    '<= ((self 'binaryExpression) '\| (self 'unaryObjectDescription))))
        (injectCascadedMessageExpression (self super) 
            (let ((res (self 'cascadedMessageExpression)))
                (res '<= ((self 'messageExpression) 
                        '& ((((#\; 'asParser) 'omit: #t) 
                            '& (((self 'keywordMessageExpression) 
                                '\| (self 'binaryMessageExpression))
                                '<= (self 'unaryMessageExpression))) 'plus)))
                (res 'semantics: (lambda (scope match) match))
                res
                ))
        (injectMessageExpression (self super)
            ((self 'messageExpression) 
                '<= (((self 'keywordExpression) '\| (self 'binaryExpression))
                        '<= (self 'unaryExpression))))
        (injectPrimary (self super)
            ((self 'primary)
                '<= (((((self 'primaryVariable) '\| (self 'literal))
                    '<= (self 'block))
                    '<= (self 'braceExpression))
                    '<= (self 'scopedExpression))))
        (preStoreBinaryObjectDescription (self super)
            ((self 'parsers) 'at:ifAbsentPut: 'binaryObjectDescription (lambda () (Parser 'named: "BINARY-OBJECT-DESCRIPTION"))))
        (preStoreCascadedMessageExpression (self super)
            ((self 'parsers) 'at:ifAbsentPut: 'cascadedMessageExpression (lambda () (Parser 'named: "CASCADED-MESSAGE-EXPRESSION"))))
        (preStoreMessageExpression (self super)
            ((self 'parsers) 'at:ifAbsentPut: 'messageExpression (lambda () (Parser 'named: "MESSAGE-EXPRESSION"))))
        (preStorePrimary (self super)
            ((self 'parsers) 'at:ifAbsentPut: 'primary (lambda () (Parser 'named: "PRIMARY"))))
       )
       ()
       )))
    
    (load "boot/test/test-smalltalk.p"))
