(let ((SmalltalkParser (newclass SmallParser Object (parsers id) ()
       ((assignmentOp (self super)
            (((":=" 'asParser) '\| #\_) 'omit: #t))
        (initializeAnnotation (self super)
            (let ((self self))
            (let ((p (Parser 'named: "ANNOTATION")))
                (p '<= ((((#\< 'asParser) 'omit: #t) '&
                            ((self 'keywordAnnotation) '\|
                             (self superelf 'unaryAnnotation)))
                            '<& ((#\> 'asParser) 'omit: #t)))
                p))
            )
        (initializeArray (self super) 
            (let ((self self))
            (let ((array (Parser 'named: "ARRAY")))
                (array '<= ((((#\( 'asParser) 'omit: #t) '&
                            (((((   (self superelf 'numberConstant) '\|
                                    (self superelf 'stringConstant)) '<=
                                    (self superelf 'symbolInArray)) '<=
                                    (self superelf 'symbolConstant)) '<=
                                    (self superelf 'characterConstant)) '<=
                                    array)) 
                            '<& ((#\) 'asParser) 'omit: #t)))
                (array 'semantics: (lambda (result) result))
                array)))
        (initializeArrayConst (self super)
            (let ((self self))
                (((#\# 'asParser) 'omit: #t) '& (self superelf 'array))))
        (initializeAssignmentExpressions (self super)
            (let ((self self))
                (((self 'variableName) '& (self superelf 'assignmentOp )) 'times)))
        (initializeBar (self super)
            ((#\| 'asParser) 'omit: #t))
        (initializeBinaryExpression (self super) ; TODO this is not complete yet
            (let ((self self))
            (self superelf 'preStoreBinaryObjectDescription)))
        (initializeBinaryMessageDefinition (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BINARY-ARGUMENT")))
                (p '<= ((self 'binarySelector) '& (self superelf 'parameterName)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBinaryMessageExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BINARY-MESSAGE-EXPRESSION")))
                (p '<= ((self 'binarySelector) '& (self superelf 'unaryObjectDescription)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBinaryObjectDescription (self super)
            (let ((self self))
                ((self 'binaryExpression)
                (self superelf 'binaryObjectDescription))))
        (initializeBinarySelector (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BINARY-SELECTOR")))
                (p '<= ((((self 'specialCharacter) '\| #\-) 'strongAnd: ((self 'specialCharacter) 'strongTimes)) '\| #\|))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBlock (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BLOCK")))
                (p '<= ((((((#\[ 'asParser) 'omit: #t) '&
                        (((self 'blockArguments) '& (self superelf 'bar)) 'optional)) '<&
                        ((self 'temporaries) 'optional)) '<&
                        (self superelf 'statements)) '<&
                        ((#\] 'asParser) 'omit: #t)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBlockArguments (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BLOCK-ARGUMENTS")))
                (p '<= ((((#\: 'asParser) 'omit: #t) '& (self superelf 'identifier)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBraceExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BRACE-EXPRESSION")))
                (p '<= (((((#\{ 'asParser) 'omit: #t) '&
                        ((self 'subExpression) 'times)) '<&
                        (self superelf 'expression)) '<&
                        ((#\} 'asParser) 'omit: #t)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCapitalIdentifier (self super)
            (let ((self self))
            (let ((p (Parser 'named: "CAPITAL-IDENTIFIER")))
                (p '<= ((self 'uppercase) 'strongAnd: (((self 'letter) '\| (self superelf 'decimalDigit)) 'strongTimes)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCascadedMessageExpression (self super)
            (let ((self self))
                (self superelf 'expression)
                (self superelf 'cascadedMessageExpression)))
        (initializeCharacter (self super) ;TODO implement, need String 'asPEGChoice
            (let ((self self)) 
                ))
        (initializeCharacterConstant (self super)
            (let ((self self))
            (let ((p (Parser 'named: "CHARACTER-CONSTANT")))
                (p '<= (((#\$ 'asParser) 'omit: #t) 'strongAnd: (self superelf 'character)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCommentFormat (self super)
            (let ((commentBorder (#\" 'asParser)))
                ((commentBorder 'strongAnd: ((commentBorder 'not) 'strongTimes)) '<& commentBorder)
                commentBorder))
        (initializeDecimalDigit (self super) ;TODO implement, need String asPEGRange
            )
        (initializeExpression (self super) ;TODO implement
            )
        (initializeFinalExpression (self super)
            (let ((self self))
                ((self 'expression) '& ((#\. 'asParser) 'omit: #t))))
        (initializeIdentifier (self super)
            (let ((self self))
            (let ((p (Parser 'named: "IDENTIFIER")))
                (p '<= ((self 'letter) 'strongAnd: (((self 'letter) '\| (self superelf 'decimalDigit)) 'strongTimes)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeyword (self super)
            (let ((self self))
                ((self 'identifier) 'strongAnd: ((#\: 'asParser) 'omit: #t))))
        (initializeKeywordAnnotation (self super)
            (let ((self self))
            (let ((p (Parser 'named: "KEYWORD-ANNOTATION")))
                (p '<= (((self 'keyword) '& (self superelf 'primary)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeywordExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "KEYWORD-EXPRESSION")))
                (p '<= ((self 'binaryObjectDescription) '& (self superelf 'keywordMessageExpression)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeywordMessageExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "KEYWORD-MESSAGE-EXPRESSION")))
                (p '<= (((self 'keyword) '& (self superelf 'binaryObjectDescription)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeywordsArguments (self super)
            (let ((self self))
            (let ((p (Parser 'named: "KEYWORDS-ARGUMENTS")))
                (p '<= (((self 'keyword) '& (self superelf 'parameterName)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeLetter (self super)
            (let ((self self))
                ((self 'lowercase) '\| (self superelf 'uppercase))))
        (initializeLiteral (self super)
            (let ((self self))
            (let ((result ((self 'numberConstant) '\| (self superelf 'symbolConstant))))
                (((result '<= (self superelf 'characterConstant)) '<= (self superelf 'stringConstant)) '<= (self superelf 'arrayConstant))
                result)))
        (initializeLowercase (self super) ;TODO implement, need String asPEGRange
            )
        (initializeMessageExpression (self super)
            (let ((self self))
                (self superelf 'expression)
                ((self 'messageExpression) 'separator: (self superelf 'separator))))
        (initializeMesssagePattern (self super)
            (let ((self self))
            (let ((p (Parser 'named: "MESSAGE-PATTERN")))
                (p '<= (((self 'keywordsArguments) '\| (self superelf 'binaryMessageDefiniton)) '<=
                            (self superelf 'unaryMessageDefinition)))
                p)))
        (initializeMethod (self super)
            (let ((self self))
            (let ((p (Parser 'named: "METHOD")))
                (p '<= (((((self 'messagePattern)
                        '& ((self 'temporaries) 'optional))
                        '<& ((self 'annotation) 'times))
                        '<& (self superelf 'statements))
                        '<& (self superelf 'separator)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeNumberConstant (self super)
            (let ((self self))
            (let ((p (Parser 'named: "NUMBER")))
                (p '<= ((self 'decimalDigit) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeParameterName (self super)
            (let ((self self))
                (self superelf 'identifier)))
        (initializePrimary (self super)
            (let ((self self))
                (self superelf 'expression)
                (self superelf 'primary)))
        (initializePrimaryVariable (self super)
            (let ((self self))
            (let ((p (Parser 'named: "PRIMARY-VARIABLE")))
                (p '<= (self superelf 'identifier))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeReturn (self super)
            (let ((self self))
            (let ((p (Parser 'named: "RETURN")))
                (p '<= (((#\^ 'asParser) 'omit: #t) '& (self superelf 'finalExpression)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeScopedExpression (self super)
            (let ((self self))
                ((((#\( 'asParser) 'omit: #t) '& (self superelf 'expression)) '<& ((#\) 'asParser) 'omit: #t))))
        (initializeSeparator (self super)
            (let ((self self))
            (let ((p (Parser 'named: "COMMENT")))
                (p '<= ((((Parser 'separator) '\| (self superelf 'commentFormat)) 'strongTimes) 'omit: #t))
                p)))
        (initializeSpecialCharacter (self super) ;TODO, need String 'asPEGChoice
            )
        (initializeStatements (self super)
            (let ((self self))
            (let ((p (Parser 'named: "STATEMENTS")))
                (p '<= (((self 'subExpression) 'times) '& (((self 'return) '\| (self superelf 'finalExpression)) 'optional)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeString (self super)
            (let* ((self self)
                   (self supertringBorder (("'" 'asParser) 'omit: #t)))
            (let ((p (Parser 'named: "STRING")))
                (p '<= (((stringBorder 'strongAnd: ((stringBorder 'not) 'strongTimes)) '<& stringBorder) 'strongPlus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeStringConstant (self super)
            (let ((self self))
            (let ((p (Parser 'named: "STRING-CONSTANT")))
                (p '<= (self superelf 'string))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeSubExpression (self super)
            (let ((self self))
                ((self 'expression) '& ((#\. 'asParser) 'omit: #t))))
        (initializeSymbol (self super)
            (let ((self self))
            (let ((p (Parser 'named: "SYMBOL")))
              (p '<= ((((self 'symbolKeywords) '\| (self superelf 'identifier)) 
                        '<= (self superelf 'binarySelector))
                        '<= (self superelf 'string)))
              p)))
        (initializeSymbolConstant (self super)
            (let ((self self))
            (let ((p (Parser 'named: "SYMBOL-CONSTANT")))
                (p '<= (((#\# 'asParser) 'omit: #t) 'strongAnd: (self superelf 'symbol)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeSymbolInArray (self super)
            (let ((self self))
            (let ((p (Parser 'named: "SYMBOL-IN-ARRAY")))
                (p '<= (self superelf 'symbol))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeSymbolKeywords (self super)
            (let ((self self))
            (let ((p (Parser 'named: "SYMBOL-KEYWORDS")))
                (p '<= ((self 'keyword) 'strongPlus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeTemporaries (self super)
            (let ((self self))
            (let ((p (Parser 'named: "TEMPORARIES")))
                (p '<= (((self 'bar) '& ((self 'variableName) 'times)) '<& (self superelf 'bar)))))) 
        (initializeUnaryAnnotation (self super)
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-ANNOTATION")))
                (p '<= (self superelf 'unarySelector))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-EXPRESSION")))
                (p '<= ((self 'primary) '& ((self 'unarySelector) 'plus)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryMessageDefinition (self super)
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-MESSSAGE-DEFINITION")))
                (p '<= (self superelf 'unarySelector))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryMessageExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-MESSSAGE-EXPRESSION")))
                (p '<= (self superelf 'unarySelector))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryObjectDescription (self super)
            (let ((self self))
                ((self 'unaryExpression) '\| (self superelf 'primary))))
        (initializeUnarySelector (self super) ;TODO implement consume
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-SELECTOR")))
                (p '<= ((self 'identifier) 'strongAnd: (((#\: 'asParser) 'not) 'consume: #f)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUppercase (self super) ;TODO implement, need String 'asPEGRange
            )
        (initializeVariableName (self super)
            (let ((self self))
            (let ((p (Parser 'named: "VARIABLE-NAME")))
                (p '<= (self superelf 'identifier))
                (p 'semantics: (lambda (result) result))
                p)))
        (injectBinaryObjectDescription (self super)
            (let ((self self))
                ((self 'binaryObjectDescription) 
                    '<= ((self 'binaryExpression) '\| (self superelf 'unaryObjectDescription)))))
        (injectCascadedMessageExpression (self super) ;TODO implement
            (let ((self self))
                ))
        (injectMessageExpression (self super)
            (let ((self self))
                ((self 'messageExpression) 
                    '<= (((self 'keywordExpression) '\| (self superelf 'binaryExpression))
                         '<= (self superelf 'unaryExpression)))))
        (injectPrimary (self super)
            (let ((self self))
                ((self 'primary)
                    '<= (((((self 'primaryVariable) '\| (self superelf 'literal))
                        '<= (self superelf 'block))
                        '<= (self superelf 'braceExpression))
                        '<= (self superelf 'scopedExpression)))))
        ;TODO accessor for parsers:
        (preStoreBinaryDescription (s)
            )
       )())))
    
    (load "boot/test/test-smalltalk.p"))
