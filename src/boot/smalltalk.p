(let ((SmalltalkParser (newclass SmallParser Object (parsers id) ()
       ((assignmentOp (self super)
            (((":=" 'asParser) '\| #\_) 'omit: #t))
        (initializeAnnotation (self super)
            (let ((self self))
            (let ((p (Parser 'named: "ANNOTATION")))
                (p '<= ((((#\< 'asParser) 'omit: #t) '&
                            ((self 'keywordAnnotation) '\|
                             (self superself 'unaryAnnotation)))
                            '<& ((#\> 'asParser) 'omit: #t)))
                p))
            )
        (initializeArray (self super) 
            (let ((self self))
            (let ((array (Parser 'named: "ARRAY")))
                (array '<= ((((#\( 'asParser) 'omit: #t) '&
                            (((((   (self superself 'numberConstant) '\|
                                    (self superself 'stringConstant)) '<=
                                    (self superself 'symbolInArray)) '<=
                                    (self superself 'symbolConstant)) '<=
                                    (self superself 'characterConstant)) '<=
                                    array)) 
                            '<& ((#\) 'asParser) 'omit: #t)))
                (array 'semantics: (lambda (result) result))
                array)))
        (initializeArrayConst (self super)
            (let ((self self))
                (((#\# 'asParser) 'omit: #t) '& (self superself 'array))))
        (initializeAssignmentExpressions (self super)
            (let ((self self))
                (((self 'variableName) '& (self superself 'assignmentOp )) 'times)))
        (initializeBar (self super)
            ((#\| 'asParser) 'omit: #t))
        (initializeBinaryExpression (self super) ; TODO this is not complete yet
            (let ((self self))
            (self superself 'preStoreBinaryObjectDescription)))
        (initializeBinaryMessageDefinition (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BINARY-ARGUMENT")))
                (p '<= ((self 'binarySelector) '& (self superself 'parameterName)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBinaryMessageExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BINARY-MESSAGE-EXPRESSION")))
                (p '<= ((self 'binarySelector) '& (self superself 'unaryObjectDescription)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBinaryObjectDescription (self super)
            (let ((self self))
                ((self 'binaryExpression)
                (self superself 'binaryObjectDescription))))
        (initializeBinarySelector (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BINARY-SELECTOR")))
                (p '<= ((((self 'specialCharacter) '\| #\-) 'strongAnd: ((self 'specialCharacter) 'strongTimes)) '\| #\|))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBlock (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BLOCK")))
                (p '<= ((((((#\[ 'asParser) 'omit: #t) '&
                        (((self 'blockArguments) '& (self superself 'bar)) 'optional)) '<&
                        ((self 'temporaries) 'optional)) '<&
                        (self superself 'statements)) '<&
                        ((#\] 'asParser) 'omit: #t)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBlockArguments (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BLOCK-ARGUMENTS")))
                (p '<= ((((#\: 'asParser) 'omit: #t) '& (self superself 'identifier)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeBraceExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "BRACE-EXPRESSION")))
                (p '<= (((((#\{ 'asParser) 'omit: #t) '&
                        ((self 'subExpression) 'times)) '<&
                        (self superself 'expression)) '<&
                        ((#\} 'asParser) 'omit: #t)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCapitalIdentifier (self super)
            (let ((self self))
            (let ((p (Parser 'named: "CAPITAL-IDENTIFIER")))
                (p '<= ((self 'uppercase) 'strongAnd: (((self 'letter) '\| (self superself 'decimalDigit)) 'strongTimes)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCascadedMessageExpression (self super)
            (let ((self self))
                (self superself 'expression)
                (self superself 'cascadedMessageExpression)))
        (initializeCharacter (self super) ;TODO implement, need String 'asPEGChoice
            (let ((self self)) 
                ))
        (initializeCharacterConstant (self super)
            (let ((self self))
            (let ((p (Parser 'named: "CHARACTER-CONSTANT")))
                (p '<= (((#\$ 'asParser) 'omit: #t) 'strongAnd: (self superself 'character)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeCommentFormat (self super)
            (let ((commentBorder (#\" 'asParser)))
                ((commentBorder 'strongAnd: ((commentBorder 'not) 'strongTimes)) '<& commentBorder)
                commentBorder))
        (initializeDecimalDigit (self super) ;TODO implement, need String asPEGRange
            )
        (initializeExpression (self super) ;TODO implement
            )
        (initializeFinalExpression (self super)
            (let ((self self))
                ((self 'expression) '& ((#\. 'asParser) 'omit: #t))))
        (initializeIdentifier (self super)
            (let ((self self))
            (let ((p (Parser 'named: "IDENTIFIER")))
                (p '<= ((self 'letter) 'strongAnd: (((self 'letter) '\| (self superself 'decimalDigit)) 'strongTimes)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeyword (self super)
            (let ((self self))
                ((self 'identifier) 'strongAnd: ((#\: 'asParser) 'omit: #t))))
        (initializeKeywordAnnotation (self super)
            (let ((self self))
            (let ((p (Parser 'named: "KEYWORD-ANNOTATION")))
                (p '<= (((self 'keyword) '& (self superself 'primary)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeywordExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "KEYWORD-EXPRESSION")))
                (p '<= ((self 'binaryObjectDescription) '& (self superself 'keywordMessageExpression)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeywordMessageExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "KEYWORD-MESSAGE-EXPRESSION")))
                (p '<= (((self 'keyword) '& (self superself 'binaryObjectDescription)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeKeywordsArguments (self super)
            (let ((self self))
            (let ((p (Parser 'named: "KEYWORDS-ARGUMENTS")))
                (p '<= (((self 'keyword) '& (self superself 'parameterName)) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeLetter (self super)
            (let ((self self))
                ((self 'lowercase) '\| (self superself 'uppercase))))
        (initializeLiteral (self super)
            (let ((self self))
            (let ((result ((self 'numberConstant) '\| (self superself 'symbolConstant))))
                (((result '<= (self superself 'characterConstant)) '<= (self superself 'stringConstant)) '<= (self superself 'arrayConstant))
                result)))
        (initializeLowercase (self super) ;TODO implement, need String asPEGRange
            )
        (initializeMessageExpression (self super)
            (let ((self self))
                (self superself 'expression)
                ((self 'messageExpression) 'separator: (self superself 'separator))))
        (initializeMesssagePattern (self super)
            (let ((self self))
            (let ((p (Parser 'named: "MESSAGE-PATTERN")))
                (p '<= (((self 'keywordsArguments) '\| (self superself 'binaryMessageDefiniton)) '<=
                            (self superself 'unaryMessageDefinition)))
                p)))
        (initializeMethod (self super)
            (let ((self self))
            (let ((p (Parser 'named: "METHOD")))
                (p '<= (((((self 'messagePattern)
                        '& ((self 'temporaries) 'optional))
                        '<& ((self 'annotation) 'times))
                        '<& (self superself 'statements))
                        '<& (self superself 'separator)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeNumberConstant (self super)
            (let ((self self))
            (let ((p (Parser 'named: "NUMBER")))
                (p '<= ((self 'decimalDigit) 'plus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeParameterName (self super)
            (let ((self self))
                (self superself 'identifier)))
        (initializePrimary (self super)
            (let ((self self))
                (self superself 'expression)
                (self superself 'primary)))
        (initializePrimaryVariable (self super)
            (let ((self self))
            (let ((p (Parser 'named: "PRIMARY-VARIABLE")))
                (p '<= (self superself 'identifier))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeReturn (self super)
            (let ((self self))
            (let ((p (Parser 'named: "RETURN")))
                (p '<= (((#\^ 'asParser) 'omit: #t) '& (self superself 'finalExpression)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeScopedExpression (self super)
            (let ((self self))
                ((((#\( 'asParser) 'omit: #t) '& (self superself 'expression)) '<& ((#\) 'asParser) 'omit: #t))))
        (initializeSeparator (self super)
            (let ((self self))
            (let ((p (Parser 'named: "COMMENT")))
                (p '<= ((((Parser 'separator) '\| (self superself 'commentFormat)) 'strongTimes) 'omit: #t))
                p)))
        (initializeSpecialCharacter (self super) ;TODO, need String 'asPEGChoice
            )
        (initializeStatements (self super)
            (let ((self self))
            (let ((p (Parser 'named: "STATEMENTS")))
                (p '<= (((self 'subExpression) 'times) '& (((self 'return) '\| (self superself 'finalExpression)) 'optional)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeString (self super)
            (let* ((self self)
                   (self supertringBorder (("'" 'asParser) 'omit: #t)))
            (let ((p (Parser 'named: "STRING")))
                (p '<= (((stringBorder 'strongAnd: ((stringBorder 'not) 'strongTimes)) '<& stringBorder) 'strongPlus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeStringConstant (self super)
            (let ((self self))
            (let ((p (Parser 'named: "STRING-CONSTANT")))
                (p '<= (self superself 'string))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeSubExpression (self super)
            (let ((self self))
                ((self 'expression) '& ((#\. 'asParser) 'omit: #t))))
        (initializeSymbol (self super)
            (let ((self self))
            (let ((p (Parser 'named: "SYMBOL")))
              (p '<= ((((self 'symbolKeywords) '\| (self superself 'identifier)) 
                        '<= (self superself 'binarySelector))
                        '<= (self superself 'string)))
              p)))
        (initializeSymbolConstant (self super)
            (let ((self self))
            (let ((p (Parser 'named: "SYMBOL-CONSTANT")))
                (p '<= (((#\# 'asParser) 'omit: #t) 'strongAnd: (self superself 'symbol)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeSymbolInArray (self super)
            (let ((self self))
            (let ((p (Parser 'named: "SYMBOL-IN-ARRAY")))
                (p '<= (self superself 'symbol))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeSymbolKeywords (self super)
            (let ((self self))
            (let ((p (Parser 'named: "SYMBOL-KEYWORDS")))
                (p '<= ((self 'keyword) 'strongPlus))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeTemporaries (self super)
            (let ((self self))
            (let ((p (Parser 'named: "TEMPORARIES")))
                (p '<= (((self 'bar) '& ((self 'variableName) 'times)) '<& (self superself 'bar)))))) 
        (initializeUnaryAnnotation (self super)
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-ANNOTATION")))
                (p '<= (self superself 'unarySelector))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-EXPRESSION")))
                (p '<= ((self 'primary) '& ((self 'unarySelector) 'plus)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryMessageDefinition (self super)
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-MESSSAGE-DEFINITION")))
                (p '<= (self superself 'unarySelector))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryMessageExpression (self super)
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-MESSSAGE-EXPRESSION")))
                (p '<= (self superself 'unarySelector))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUnaryObjectDescription (self super)
            (let ((self self))
                ((self 'unaryExpression) '\| (self superself 'primary))))
        (initializeUnarySelector (self super) ;TODO implement consume
            (let ((self self))
            (let ((p (Parser 'named: "UNARY-SELECTOR")))
                (p '<= ((self 'identifier) 'strongAnd: (((#\: 'asParser) 'not) 'consume: #f)))
                (p 'semantics: (lambda (result) result))
                p)))
        (initializeUppercase (self super) ;TODO implement, need String 'asPEGRange
            )
        (initializeVariableName (self super)
            (let ((self self))
            (let ((p (Parser 'named: "VARIABLE-NAME")))
                (p '<= (self superself 'identifier))
                (p 'semantics: (lambda (result) result))
                p)))
        (injectBinaryObjectDescription (self super)
            (let ((self self))
                ((self 'binaryObjectDescription) 
                    '<= ((self 'binaryExpression) '\| (self superself 'unaryObjectDescription)))))
        (injectCascadedMessageExpression (self super) ;TODO implement
            (let ((self self))
                ))
        (injectMessageExpression (self super)
            (let ((self self))
                ((self 'messageExpression) 
                    '<= (((self 'keywordExpression) '\| (self superself 'binaryExpression))
                         '<= (self superself 'unaryExpression)))))
        (injectPrimary (self super)
            (let ((self self))
                ((self 'primary)
                    '<= (((((self 'primaryVariable) '\| (self superself 'literal))
                        '<= (self superself 'block))
                        '<= (self superself 'braceExpression))
                        '<= (self superself 'scopedExpression)))))
        ;TODO accessor for parsers:
        (preStoreBinaryDescription (s)
            )
       )())))
    
    (load "boot/test/test-smalltalk.p"))
