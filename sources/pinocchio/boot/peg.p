(letrec ((car (lambda (cons) (cons 'car)))
         (cdr (lambda (cons) (cons 'cdr)))
         (Cons (newclass Cons Object (car cdr) ()
                ((car (s) ((getself s) 'objectAt: 0))
                 (car: (s new) ((getself s) 'objectAt:put: 0 new))
                 (cdr (s) ((getself s) 'objectAt: 1))
                 (cdr: (s new) ((getself s) 'objectAt:put: 1 new)))
                ()))
         (cons (lambda (l r)
            (let ((result (Cons 'new)))
                (result 'car: l)
                (result 'cdr: r)
                result)))
         (reverse (lambda (l)
            (let loop ((input l)
                       (result null))
                (if (eq? input null)
                    result
                    (loop (cdr input)
                          (cons (car input) result))))))
         (length (lambda (l)
            (let loop ((input l)
                       (result 0))
                (if (eq? input null)
                    result
                    (loop (cdr input) (+ result 1))))))
                    
         (StringScanner (newclass StringScanner Object 
                        (string position) ()
                ((pos        (s) ((getself s) 'objectAt: 1))
                 (pos:       (s new) ((getself s) 'objectAt:put: 1 new))
                 (string     (s) ((getself s) 'objectAt: 0))
                 (string:    (s new) ((getself s) 'objectAt:put: 0 new))
                 (next       (s)  
                      (let* ((self (getself s))
                             (pos  (self 'pos))
                             (res  ((self 'string) 'objectAt: pos)))
                          (self 'objectAt:put: 1 (+ pos 1))
                          res))
                 (initialize (s) ((getself s) 'pos: 0) (getself s))
                 (skipWhitespaceWith: (s scope) (getself s))
                 (atEnd      (s) (let ((self (getself s)))
                              (= (self 'pos) 
                                 ((self 'string) 'size)))))
                ((on:        (s str) (let ((result ((getself s) 'new)))
                                  (result 'string: str)
                                  result)))))

       (Expression (newclass Expression Object (name omit) ()
            ((printString (s)
                (let ((self (getself s)))
                    (display (self 'name))
                    (display " (")
                    (display ((self 'class) 'name))
                    (display ")\n")))
             (match:in: (s input scope)
                (let* ((self (getself s))
                       (save (input 'pos))
                       (match (self 'privateMatch:in: input scope)))
                    (if (eq? match null)
                        (input 'pos: save)
                        (begin))
                    match))
             (privateMatch:in: (s input scope)
                ((getself s) 'subclassResponsibility))
             (asParser (s) (getself s))
             (name (s) ((getself s) 'objectAt: 0))
             (name: (s new) ((getself s) 'objectAt:put: 0 new))
             (omit (s) ((getself s) 'objectAt: 1))
             (omit: (s new) ((getself s) 'objectAt:put: 1 new))
             (plus (s) (OneOrMore 'for: (getself s)))
             (times (s) (ZeroOrMore 'for: (getself s)))
             (and (s) (AndPredicate 'for: (getself s)))
             (not (s) (NotPredicate 'for: (getself s)))
             (minus (s) (let ((result (NotPredicate 'for: (getself s))))
                            (result 'consume: #f)))
             (& (s other)
                (Sequence 'on:
                    (list (getself s) (other 'asParser))))
             (\| (s other)
                (OrderedChoice 'on:
                    (list (getself s) (other 'asParser))))
             (strongAnd: (s other)
                (let ((result ((getself s) '& other)))
                    (result 'skipWhitespace: #f)
                    result))
             (? (s) (ZeroOrOne 'for: (getself s)))
             (* (s) ((getself s) 'times))
             (strongTimes (s) (let ((result ((getself s) '*)))
                                (result 'skipWhitespace: #f)
                                result))
             (+ (s) ((getself s) 'plus))
             (strongPlus (s) (let ((result ((getself s) '+)))
                                (result 'skipWhitespace: #f)
                                result)))
            ()))

       (Sequence
            (newclass Sequence Expression (children skipWhitespace) ()
                ((children          (s) ((getself s) 'objectAt: 2))
                 (children:         (s new)
                    ((getself s) 'objectAt:put: 2 new))
                 (skipWhitespace    (s) ((getself s) 'objectAt: 3))
                 (skipWhitespace:   (s new)
                    ((getself s) 'objectAt:put: 3 new))
                 (initialize (s)
                    (let ((self (getself s)))
                        (self 'omit: #f)
                        (self 'skipWhitespace: #t)
                        self))
                 (privateMatch:in: (s input scope)
                    (let ((self (getself s)))
                        (let loop ((matches null)
                                   (children (self 'children)))
                            (if (eq? children null)
                                (if (= (length matches) 1)
                                    (car matches)
                                    (reverse matches))
                                (let ((expr (car children)))
                                    (if (self 'skipWhitespace)
                                        (begin (input 'skipWhitespaceWith: scope))
                                        (begin))
                                    (let ((match (expr 'match:in: input scope)))
                                        (if (eq? null match)
                                            match
                                            (loop
                                                (if (expr 'omit)
                                                    matches
                                                    (cons match matches))
                                                (cdr children)))))))))
                )
                ((on: (s children)
                    (let ((result ((getself s) 'new)))
                        (result 'children: children)
                        result))
                )
            ))
       (OrderedChoice
            (newclass OrderedChoice Expression (children) ()
                ((children (s) ((getself s) 'objectAt: 2))
                 (children: (s new) ((getself s) 'objectAt:put: 2 new))
                 (privateMatch:in: (s input scope)
                    (let ((self (getself s)))
                        (let loop ((children (self 'children)))
                            (if (eq? null children)
                                null
                                (let* ((expr (car children))
                                       (match (expr 'match:in: input scope)))
                                    (if (eq? null match)
                                        (loop (cdr children))
                                        match))))))
                )
                ((on: (s children)
                    (let ((result ((getself s) 'new)))
                        (result 'children: children)
                        result)))
            ))
       (Repetition
            (newclass Repetition Expression (child skipWhitespace) ()
                ((child (s) ((getself s) 'objectAt: 2))
                 (child: (s new) ((getself s) 'objectAt:put: 2 new))
                 (skipWhitespace (s) ((getself s) 'objectAt: 3))
                 (skipWhitespace: (s new)
                    ((getself s) 'objectAt:put: 3 new))
                 (initialize (s)
                    (let ((self (getself s)))
                        (self 'skipWhitespace: #t)
                        self))
                 (privateMatch:in: (s input scope)
                    (let* ((self (getself s))
                           (child (self 'child)))
                        (let loop ((matches null)
                                   (save (input 'pos))
                                   (match (child 'match:in: input scope)))
                            (if (eq? match null)
                                (begin
                                    (input 'pos: save)
                                    (reverse matches))
                                (let ((pos (input 'pos)))
                                    (if (self 'skipWhitespace)
                                        (input 'skipWhitespaceWith: scope)
                                        (begin))
                                    (loop (cons match matches)
                                          pos
                                          (child 'match:in: input scope)))))))
                )
                ((for: (s child)
                    (let ((result ((getself s) 'new)))
                        (result 'child: child)
                        result)))
            ))
       (OneOrMore
            (newclass OneOrMore Repetition () ()
                ()
                ()
            ))
       (ZeroOrMore
            (newclass ZeroOrMore Repetition () ()
                ((privateMatch:in: (s input scope)
                    (let ((match ((getsuper s)
                                    (vector 'privateMatch:in: input scope))))
                        (if (eq? null match)
                            (list "")
                            match))))
                ()
            ))
       (ZeroOrOne
            (newclass ZeroOrOne Repetition () ()
                ()
                ()
            ))
       (AndPredicate
            (newclass AndPredicate Repetition () ()
                ()
                ()
            ))
       (NotPredicate
            (newclass NotPredicate Repetition (consume) ()
                ()
                ()
            ))
       (Terminal
            (newclass Terminal Expression (char) ()
                ((char (s) ((getself s) 'objectAt: 2))
                 (char: (s new) ((getself s) 'objectAt:put: 2 new))
                 (initialize (s)
                    (let ((self (getself s)))
                        (self 'omit: #f)
                        self))
                 (privateMatch:in: (s input scope)
                    (let* ((self (getself s))
                           (char (self 'char)))
                        (if (= (input 'next) char) char null)))
                )
                ((char: (s char)
                    (let ((result ((getself s) 'new)))
                        (result 'char: char)
                        result)))
            ))
        )

        (Character 'store:method: 'asParser
            (method (s) (Terminal 'char: (getself s))))

       (load "boot/test/test-peg.p")

       ;(Object 'bla)
)
